Machine learning
****************

Introduction
============

Hyperspy provides easy access to several machine learning algorithms which can
be useful when analysing hyperspectral data. In particular, decomposition 
algorithms such as principal component analysis (PCA) or blind source separation
algorithms such as independent component analysis (ICA) are available through
the methods described in this section.

.. NOTE::

   In version 0.3.0beta3 the syntax for most of the machine-learning functions
   have changed. It follows a summary of the changes:
   
   * `principal_components_analysis` was renamed to `Spectrum.decomposition`
   * `independent_components_analysis` was renamed to `Spectrum.blind_source_separation`
   * `pca_build_SI` was renamed to `get_decomposition_model`
   * `ica_build_SI` was renamed to `get_bss_model`
   * `plot_lev` was rename to `Spectrum.plot_explained_variance_ratio`
   
   
.. _decomposition:

Decomposition
=============

There are several methods to decompose a matrix or tensor into several factors.
The decomposition is most commonly applied as a means of noise reduction and
dimensionality reduction. One of the most popular decomposition methods is
principal component analysis (PCA). To perform PCA on your data set,
run the following command:

.. code-block:: python

    s.decomposition()

There are several options for `decomposition`, including data pre-treatment and
the algorithm used to compute the analysis.  If you're curious, please
review these options using the ? syntax of ipython:

.. code-block:: python

    s.decomposition?

The default algorithm used when running `decomposition` is `SVD`, which performs
PCA using singular value decomposition.


Poissonian noise
----------------

Most decomposition algorithms assume that the noise of the data follows a
Gaussian distribution. In the case that the data that you are analysing follow
a Poissonian distribution instead Hyperspy can "normalise" the data by
performing a scaling operation which can greatly enhance the result.

To perform Poissonian noise normalisation:

.. code-block:: python

    # The long way:
    s.decomposition(normalize_poissonian_noise = True)
    
    # Because it is the first argument we cold have simple written:
    s.decomposition(True)
    
For more details about the scaling procedure you can consult the 
`following research article <http://onlinelibrary.wiley.com/doi/10.1002/sia.1657/abstract>`_

.. _decomposition-nomenclature:

Nomenclature
------------
Hyperspy performs the decomposition of a dataset into two datasets:
one with the dimension of the signal space called `factors` and the other with 
the dimension of the navigation space called `scores`.
The same nomenclature applies to the result of BSS.


Principal component analysis
----------------------------

.. _scree-plot:

Scree plot
^^^^^^^^^^

When using PCA it is often useful to estimate the dimensionality of the data
by plotting the explained variance against the component index in a
logarithmic y-scale. This plot is sometimes called scree-plot and it drops
quickly, eventually becoming a slowly descending line. The point at which it
becomes linear (often referred to as an elbow) is generally judged to be a good
estimation of the dimensionality of the data.

To obtain a scree plot, run the following command:

.. code-block:: python

    s.plot_explained_variance_ratio()
    
Data denoising
--------------

One of the most popular uses of PCA is data denoising. The denoising property
is achieved by using a limited set of components to make a model of the
original, omitting the later components that ideally contain only noise.

To perform this operation with Hyperspy run the following command, usually after
estimating the dimension of your data e.g. by using the :ref:`scree-plot` if
your algorithm of choice is PCA.

.. code-block:: python

    sc = s.get_decomposition_model(components)

.. NOTE:: 
    The components argument can be one of several things (None, int,
    or list of ints):

    * if None, all the components are used to construct the model.
    * if int, only the given number of components (starting from index 0) are used to construct the model.
    * if list of ints, only the components in the given list are used to
    construct the model.

.. NOTE::
    Unlike most of the analysis functions, this function returns a new
    object.  The new object is something that you have to give a
    handle to, so that you can perform operations on that object later.
    That is why we use the `sc = s.get_decomposition_model(components)`,
    which simply assign the object returned by the `get_decomposition_model` 
    method to the variable `sc`. The name of the variable is totally arbitrary
    and therefore you can choose it at your will. The returned object is
    a clone of the original `s` object, where the data has been replaced by the
    model constructed using the chosen components.

It is usually important to examine the residuals between your original
data and your reconstructed data.  If you
have any recognizable structure in either the image space or the
spectral space, that means you did not include enough components in
your reconstruction, and you have lost important experimental
information.  To examine residuals, use the plot_residual method on
the reconstructed object.

.. code-block:: python

    sc.plot_residual()


Blind Source Separation
=======================

In some cases (it largely depends on the particular application) it is possible
to obtain physically meaninful components from the result of a data
decomposition by Blind Source Separation (BSS).

To perform BSS on the result of a decomposition, run the following command:

.. code-block:: python

    s.blind_source_separation(number_of_components)

.. NOTE::
    You must have performed a :ref:`decomposition` before you attempt to 
    perform BSS.

.. NOTE::
    You must pass an integer number of components to ICA.  The best
    way to estimate this number in the case of a PCA decomposition is by
    inspecting the :ref:`scree-plot`.


Visualising results
===================

Plot methods exist for the results of decomposition and blind source separation.
All the methods begin with plot: `s.plot_decomposition_factors`,
`s.plot_decomposition_scores`, `s.plot_bss_factors`, `s.plot_bss_scores`


Saving and loading results
==========================
There are several methods to store  the result of a machine learning 
analysis.

Saving in the main file
-------------------------
When you save the object on which you've performed machine learning
analysis in the :ref:`hdf5-format` format (the default in Hyperspy)
(see :ref:`saving_files`) the result of the analysis is automatically saved in
the file and it is loaded with the rest of the data when you load the file.

This option is the simplest because everything is stored in the same file and
it does not require any extra command to recover the result of machine learning
analysis when loading a file. However, it supports storing only one
decomposition and one BSS result, what may not be enough for your purposes.

Saving to an external files
---------------------------
Alternatively, to save the results of the current machine learning analysis 
to a file you can use `s.mva_results.save`, e.g.:

.. code-block:: python
    
    # To save the result of the analysis
    s.mva_results.save('my_results')
    
    # To load back the results
    s.mva_results.load('my_results.npz')
    
    
Exporting
---------
To load the results s
the specialized **exportPca_results** and
**exportIca_results** methods.  This has the advantage of being
easier to import into other data analysis programs, such as Digital
Micrograph.

.. code-block:: python

    # save the entire object
    s.save(filename)
    # save the principal components and scores to files themselves
    s.exportPca_results()
    # save the independent components to the rpl format, which is
    #   easily importable into Digital Micrograph
    s.exportIca_results(factor_format='rpl', score_format='rpl')



