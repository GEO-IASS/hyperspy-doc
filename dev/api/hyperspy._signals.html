<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>hyperspy._signals package &mdash; HyperSpy 0.8+dev documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.8+dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../_static/hyperspy_logo.ico"/>
    <link rel="top" title="HyperSpy 0.8+dev documentation" href="../index.html" />
 
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-25260850-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">HyperSpy 0.8+dev documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="hyperspy-signals-package">
<h1>hyperspy._signals package<a class="headerlink" href="#hyperspy-signals-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-hyperspy._signals.dielectric_function">
<span id="hyperspy-signals-dielectric-function-module"></span><h2>hyperspy._signals.dielectric_function module<a class="headerlink" href="#module-hyperspy._signals.dielectric_function" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.dielectric_function.DielectricFunction">
<em class="property">class </em><tt class="descclassname">hyperspy._signals.dielectric_function.</tt><tt class="descname">DielectricFunction</tt><span class="sig-paren">(</span><em>*args</em>, <em>**kwards</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.dielectric_function.DielectricFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.spectrum.Spectrum" title="hyperspy._signals.spectrum.Spectrum"><tt class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.spectrum.Spectrum</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">align1D</span></tt>([start,&nbsp;end,&nbsp;reference_indices,&nbsp;...])</td>
<td>Estimate the shifts in the signal axis using cross-correlation and use the estimation to align the data in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">align2D</span></tt>([crop,&nbsp;fill_value,&nbsp;shifts,&nbsp;roi,&nbsp;...])</td>
<td>Align the images in place using user provided shifts or by estimating the shifts.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">anscombe</span></tt>()</td>
<td>Anscombe transform.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">anscombe_inverse</span></tt>([method])</td>
<td>Inverse anscombe transform.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_image</span></tt>(image_axes)</td>
<td>Convert signal to image.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_spectrum</span></tt>(spectral_axis)</td>
<td>Return the Signal as a spectrum.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">blind_source_separation</span></tt>([...])</td>
<td>Blind source separation (BSS) on the result on the decomposition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">calibrate</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Calibrate the spectral dimension using a gui.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_dtype</span></tt>(dtype)</td>
<td>Change the data type.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop</span></tt>(axis[,&nbsp;start,&nbsp;end])</td>
<td>Crops the data in a given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop_image</span></tt>([top,&nbsp;bottom,&nbsp;left,&nbsp;right])</td>
<td>Crops an image in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop_spectrum</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Crop in place the spectral dimension.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">decomposition</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Decomposition with a choice of algorithms</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">deepcopy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">diff</span></tt>(axis[,&nbsp;order])</td>
<td>Returns a signal with the n-th order discrete difference along given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_peak_width</span></tt>([factor,&nbsp;window,&nbsp;...])</td>
<td>Estimate the width of the highest intensity of peak of the spectra at a given fraction of its maximum.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_poissonian_noise_variance</span></tt>([...])</td>
<td>Estimate the poissonian noise variance of the signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift1D</span></tt>([start,&nbsp;end,&nbsp;...])</td>
<td>Estimate the shifts in the current signal axis using  cross-correlation.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift2D</span></tt>([reference,&nbsp;...])</td>
<td>Estimate the shifts in a image using phase correlation</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">export_bss_results</span></tt>([comp_ids,&nbsp;folder,&nbsp;...])</td>
<td>Export results from ICA to any of the supported formats.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">export_decomposition_results</span></tt>([comp_ids,&nbsp;...])</td>
<td>Export results from a decomposition to any of the supported formats.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">filter_butterworth</span></tt>([cutoff_frequency_ratio,&nbsp;...])</td>
<td>Butterworth filter in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">find_peaks1D_ohaver</span></tt>([xdim,&nbsp;slope_thresh,&nbsp;...])</td>
<td>Find peaks along a 1D line (peaks in spectrum/spectra).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">fold</span></tt>(*args,&nbsp;**kwargs)</td>
<td>If the signal was previously unfolded, folds it back</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">gaussian_filter</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Applies a Gaussian filter in the spectral dimension in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_factors</span></tt>()</td>
<td>Return the blind source separtion factors as a Signal.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_loadings</span></tt>()</td>
<td>Return the blind source separtion loadings as a Signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_model</span></tt>([components])</td>
<td>Return the spectrum generated with the selected number of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_current_signal</span></tt>([auto_title,&nbsp;auto_filename])</td>
<td>Returns the data at the current coordinates as a Signal subclass.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_factors</span></tt>()</td>
<td>Return the decomposition factors as a Signal.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_loadings</span></tt>()</td>
<td>Return the decomposition loadings as a Signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_model</span></tt>([components])</td>
<td>Return the spectrum generated with the selected number of principal</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_dimensions_from_data</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Get the dimension parameters from the data_cube.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hyperspy._signals.dielectric_function.DielectricFunction.get_electron_energy_loss_spectrum" title="hyperspy._signals.dielectric_function.DielectricFunction.get_electron_energy_loss_spectrum"><tt class="xref py py-obj docutils literal"><span class="pre">get_electron_energy_loss_spectrum</span></tt></a>(zlp,&nbsp;t)</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_explained_variance_ratio</span></tt>()</td>
<td>Return the explained variation ratio of the PCA components as a Spectrum.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_histogram</span></tt>(img[,&nbsp;bins,&nbsp;range_bins])</td>
<td>Return a histogram of the signal data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hyperspy._signals.dielectric_function.DielectricFunction.get_number_of_effective_electrons" title="hyperspy._signals.dielectric_function.DielectricFunction.get_number_of_effective_electrons"><tt class="xref py py-obj docutils literal"><span class="pre">get_number_of_effective_electrons</span></tt></a>(nat[,&nbsp;...])</td>
<td>Compute the number of effective electrons using the Bethe f-sum         rule.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">hanning_taper</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Apply a hanning taper to the data in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">indexmax</span></tt>(axis)</td>
<td>Returns a signal with the index of the maximum along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate1D</span></tt>(axis)</td>
<td>Integrate the signal over the given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate_in_range</span></tt>([signal_range])</td>
<td>Sums the spectrum over an energy range, giving the integrated area.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate_simpson</span></tt>(axis)</td>
<td>Returns a signal with the result of calculating the integral of the signal along an axis using Simpson&#8217;s rule.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">interpolate_in_between</span></tt>(start,&nbsp;end[,&nbsp;delta,&nbsp;...])</td>
<td>Replace the data in a given range by interpolation.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">map</span></tt>(function[,&nbsp;show_progressbar])</td>
<td>Apply a function to the signal data at all the coordinates.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">max</span></tt>(axis[,&nbsp;return_signal])</td>
<td>Returns a signal with the maximum of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">mean</span></tt>(axis)</td>
<td>Returns a signal with the average of the signal along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">min</span></tt>(axis)</td>
<td>Returns a signal with the minimum of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">next</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">normalize_factors</span></tt>([which,&nbsp;by,&nbsp;sort])</td>
<td>Normalises the factors and modifies the loadings</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">normalize_poissonian_noise</span></tt>([...])</td>
<td>Scales the SI following Surf.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot</span></tt>([navigator,&nbsp;axes_manager])</td>
<td>Plot the signal at the current coordinates.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_factors</span></tt>([comp_ids,&nbsp;calibrate,&nbsp;...])</td>
<td>Plot factors from blind source separation results.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_loadings</span></tt>([comp_ids,&nbsp;calibrate,&nbsp;...])</td>
<td>Plot loadings from ICA</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_results</span></tt>([factors_navigator,&nbsp;...])</td>
<td>Plot the blind source separation factors and loadings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_cumulative_explained_variance_ratio</span></tt>([n])</td>
<td>Plot the principal components explained variance up to the</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_factors</span></tt>([comp_ids,&nbsp;...])</td>
<td>Plot factors from a decomposition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_loadings</span></tt>([comp_ids,&nbsp;...])</td>
<td>Plot loadings from PCA.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_results</span></tt>([...])</td>
<td>Plot the decompostion factors and loadings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_explained_variance_ratio</span></tt>([n,&nbsp;log])</td>
<td>Plot the decomposition explained variance ratio vs index number.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">print_summary_statistics</span></tt>([formatter])</td>
<td>Prints the five-number summary statistics of the data, the mean and the standard deviation.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">rebin</span></tt>(new_shape)</td>
<td>Returns the object with the data rebinned.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">remove_background</span></tt>([signal_range,&nbsp;...])</td>
<td>Remove the background, either in place using a gui or returned as a new spectrum using the command line.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse_bss_component</span></tt>(component_number)</td>
<td>Reverse the independent component</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse_decomposition_component</span></tt>(component_number)</td>
<td>Reverse the decomposition component</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">rollaxis</span></tt>(axis,&nbsp;to_axis)</td>
<td>Roll the specified axis backwards, until it lies in a given position.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">save</span></tt>([filename,&nbsp;overwrite,&nbsp;extension])</td>
<td>Saves the signal in the specified format.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_signal_origin</span></tt>(origin)</td>
<td>Set the origin of the signal and change the current class accordingly if pertinent.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_signal_type</span></tt>(signal_type)</td>
<td>Set the signal type and change the current class accordingly if pertinent.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">shift1D</span></tt>(shift_array[,&nbsp;interpolation_method,&nbsp;...])</td>
<td>Shift the data in place over the signal axis by the amount specified by an array.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_lowess</span></tt>([smoothing_parameter,&nbsp;...])</td>
<td>Lowess data smoothing in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_savitzky_golay</span></tt>([polynomial_order,&nbsp;...])</td>
<td>Apply a Savitzky-Golay filter to the data in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_tv</span></tt>([smoothing_parameter,&nbsp;...])</td>
<td>Total variation data smoothing in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">spikes_removal_tool</span></tt>([signal_mask,&nbsp;...])</td>
<td>Graphical interface to remove spikes from EELS spectra.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">split</span></tt>([axis,&nbsp;number_of_parts,&nbsp;step_sizes])</td>
<td>Splits the data into several signals.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">squeeze</span></tt>()</td>
<td>Remove single-dimensional entries from the shape of an array and the axes.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">std</span></tt>(axis)</td>
<td>Returns a signal with the standard deviation of the signal along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">sum</span></tt>(axis)</td>
<td>Sum the data over the given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">swap_axes</span></tt>(axis1,&nbsp;axis2)</td>
<td>Swaps the axes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_EDS</span></tt>([microscope])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_EELS</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_image</span></tt>()</td>
<td>Returns the spectrum as an image.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">undo_treatments</span></tt>()</td>
<td>Undo normalize_poissonian_noise</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold</span></tt>()</td>
<td>Modifies the shape of the data by unfolding the signal and</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_if_multidim</span></tt>()</td>
<td>Unfold the datacube if it is &gt;2D</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_navigation_space</span></tt>()</td>
<td>Modify the shape of the data to obtain a navigation space of</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_signal_space</span></tt>()</td>
<td>Modify the shape of the data to obtain a signal space of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">valuemax</span></tt>(axis)</td>
<td>Returns a signal with the value of the maximum along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">var</span></tt>(axis)</td>
<td>Returns a signal with the variances of the signal along an axis.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="hyperspy._signals.dielectric_function.DielectricFunction.get_electron_energy_loss_spectrum">
<tt class="descname">get_electron_energy_loss_spectrum</tt><span class="sig-paren">(</span><em>zlp</em>, <em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.dielectric_function.DielectricFunction.get_electron_energy_loss_spectrum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hyperspy._signals.dielectric_function.DielectricFunction.get_number_of_effective_electrons">
<tt class="descname">get_number_of_effective_electrons</tt><span class="sig-paren">(</span><em>nat</em>, <em>cumulative=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.dielectric_function.DielectricFunction.get_number_of_effective_electrons" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Compute the number of effective electrons using the Bethe f-sum</dt>
<dd><p class="first">rule.</p>
<p class="last">The Bethe f-sum rule gives rise to two definitions of the effective
number (see <a class="reference internal" href="../user_guide/bibliography.html#egerton2011" id="id1">[Egerton2011]</a>):
$n_{mathrm{eff}}left(-Imleft(epsilon^{-1}</p>
</dd>
</dl>
<p>ight)
ight)$ that</p>
<blockquote>
<div>we&#8217;ll call neff1 and
$n_{mathrm{eff}}left(epsilon_{2}</div></blockquote>
<dl class="docutils">
<dt>ight)$ that we&#8217;ll call neff2. This</dt>
<dd>method computes both.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nat: float</strong> :</p>
<blockquote>
<div><blockquote>
<div><p>Number of atoms (or molecules) per unit volume of the
sample.</p>
</div></blockquote>
<dl class="docutils">
<dt>cumulative <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If False calculate the number of effective electrons up to the
higher energy-loss of the spectrum. If True, calculate the
number of effective electrons as a function of the energy-loss up
to the higher energy-loss of the spectrum. <em>True is only supported
by SciPy newer than 0.13.2</em>.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>neff1, neff2: Signal</strong> :</p>
<blockquote class="last">
<div><p>Signal instances containing neff1 and neff2. The signal and
navigation dimensions are the same as the current signal if
<cite>cumulative</cite> is True, otherwise the signal dimension is 0
and the navigation dimension is the same as the current
signal.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<table class="docutils citation" frame="void" id="egerton2011" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Egerton2011]</td><td>Ray Egerton, &#8220;Electron Energy-Loss</td></tr>
</tbody>
</table>
<p>Spectroscopy in the Electron Microscope&#8221;, Springer-Verlag, 2011.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.eds">
<span id="hyperspy-signals-eds-module"></span><h2>hyperspy._signals.eds module<a class="headerlink" href="#module-hyperspy._signals.eds" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.eds.EDSSpectrum">
<em class="property">class </em><tt class="descclassname">hyperspy._signals.eds.</tt><tt class="descname">EDSSpectrum</tt><span class="sig-paren">(</span><em>*args</em>, <em>**kwards</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDSSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.spectrum.Spectrum" title="hyperspy._signals.spectrum.Spectrum"><tt class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.spectrum.Spectrum</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#hyperspy._signals.eds.EDSSpectrum.add_elements" title="hyperspy._signals.eds.EDSSpectrum.add_elements"><tt class="xref py py-obj docutils literal"><span class="pre">add_elements</span></tt></a>(elements)</td>
<td>Add elements and the corresponding X-ray lines.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hyperspy._signals.eds.EDSSpectrum.add_lines" title="hyperspy._signals.eds.EDSSpectrum.add_lines"><tt class="xref py py-obj docutils literal"><span class="pre">add_lines</span></tt></a>([lines,&nbsp;only_one,&nbsp;only_lines])</td>
<td>Add X-rays lines to the internal list.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">align1D</span></tt>([start,&nbsp;end,&nbsp;reference_indices,&nbsp;...])</td>
<td>Estimate the shifts in the signal axis using cross-correlation and use the estimation to align the data in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">align2D</span></tt>([crop,&nbsp;fill_value,&nbsp;shifts,&nbsp;roi,&nbsp;...])</td>
<td>Align the images in place using user provided shifts or by estimating the shifts.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">anscombe</span></tt>()</td>
<td>Anscombe transform.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">anscombe_inverse</span></tt>([method])</td>
<td>Inverse anscombe transform.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_image</span></tt>(image_axes)</td>
<td>Convert signal to image.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_spectrum</span></tt>(spectral_axis)</td>
<td>Return the Signal as a spectrum.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">blind_source_separation</span></tt>([...])</td>
<td>Blind source separation (BSS) on the result on the decomposition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">calibrate</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Calibrate the spectral dimension using a gui.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_dtype</span></tt>(dtype)</td>
<td>Change the data type.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop</span></tt>(axis[,&nbsp;start,&nbsp;end])</td>
<td>Crops the data in a given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop_image</span></tt>([top,&nbsp;bottom,&nbsp;left,&nbsp;right])</td>
<td>Crops an image in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop_spectrum</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Crop in place the spectral dimension.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">decomposition</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Decomposition with a choice of algorithms</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">deepcopy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">diff</span></tt>(axis[,&nbsp;order])</td>
<td>Returns a signal with the n-th order discrete difference along given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_peak_width</span></tt>([factor,&nbsp;window,&nbsp;...])</td>
<td>Estimate the width of the highest intensity of peak of the spectra at a given fraction of its maximum.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_poissonian_noise_variance</span></tt>([...])</td>
<td>Estimate the poissonian noise variance of the signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift1D</span></tt>([start,&nbsp;end,&nbsp;...])</td>
<td>Estimate the shifts in the current signal axis using  cross-correlation.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift2D</span></tt>([reference,&nbsp;...])</td>
<td>Estimate the shifts in a image using phase correlation</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">export_bss_results</span></tt>([comp_ids,&nbsp;folder,&nbsp;...])</td>
<td>Export results from ICA to any of the supported formats.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">export_decomposition_results</span></tt>([comp_ids,&nbsp;...])</td>
<td>Export results from a decomposition to any of the supported formats.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">filter_butterworth</span></tt>([cutoff_frequency_ratio,&nbsp;...])</td>
<td>Butterworth filter in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">find_peaks1D_ohaver</span></tt>([xdim,&nbsp;slope_thresh,&nbsp;...])</td>
<td>Find peaks along a 1D line (peaks in spectrum/spectra).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">fold</span></tt>(*args,&nbsp;**kwargs)</td>
<td>If the signal was previously unfolded, folds it back</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">gaussian_filter</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Applies a Gaussian filter in the spectral dimension in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_factors</span></tt>()</td>
<td>Return the blind source separtion factors as a Signal.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_loadings</span></tt>()</td>
<td>Return the blind source separtion loadings as a Signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_model</span></tt>([components])</td>
<td>Return the spectrum generated with the selected number of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_current_signal</span></tt>([auto_title,&nbsp;auto_filename])</td>
<td>Returns the data at the current coordinates as a Signal subclass.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_factors</span></tt>()</td>
<td>Return the decomposition factors as a Signal.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_loadings</span></tt>()</td>
<td>Return the decomposition loadings as a Signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_model</span></tt>([components])</td>
<td>Return the spectrum generated with the selected number of principal</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_dimensions_from_data</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Get the dimension parameters from the data_cube.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_explained_variance_ratio</span></tt>()</td>
<td>Return the explained variation ratio of the PCA components as a Spectrum.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_histogram</span></tt>(img[,&nbsp;bins,&nbsp;range_bins])</td>
<td>Return a histogram of the signal data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hyperspy._signals.eds.EDSSpectrum.get_lines_intensity" title="hyperspy._signals.eds.EDSSpectrum.get_lines_intensity"><tt class="xref py py-obj docutils literal"><span class="pre">get_lines_intensity</span></tt></a>([xray_lines,&nbsp;...])</td>
<td>Return the intensity map of selected Xray lines.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hyperspy._signals.eds.EDSSpectrum.get_take_off_angle" title="hyperspy._signals.eds.EDSSpectrum.get_take_off_angle"><tt class="xref py py-obj docutils literal"><span class="pre">get_take_off_angle</span></tt></a>()</td>
<td>Calculate the take-off-angle (TOA).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">hanning_taper</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Apply a hanning taper to the data in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">indexmax</span></tt>(axis)</td>
<td>Returns a signal with the index of the maximum along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate1D</span></tt>(axis)</td>
<td>Integrate the signal over the given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate_in_range</span></tt>([signal_range])</td>
<td>Sums the spectrum over an energy range, giving the integrated area.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate_simpson</span></tt>(axis)</td>
<td>Returns a signal with the result of calculating the integral of the signal along an axis using Simpson&#8217;s rule.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">interpolate_in_between</span></tt>(start,&nbsp;end[,&nbsp;delta,&nbsp;...])</td>
<td>Replace the data in a given range by interpolation.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">map</span></tt>(function[,&nbsp;show_progressbar])</td>
<td>Apply a function to the signal data at all the coordinates.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">max</span></tt>(axis[,&nbsp;return_signal])</td>
<td>Returns a signal with the maximum of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">mean</span></tt>(axis)</td>
<td>Returns a signal with the average of the signal along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">min</span></tt>(axis)</td>
<td>Returns a signal with the minimum of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">next</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">normalize_factors</span></tt>([which,&nbsp;by,&nbsp;sort])</td>
<td>Normalises the factors and modifies the loadings</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">normalize_poissonian_noise</span></tt>([...])</td>
<td>Scales the SI following Surf.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot</span></tt>([navigator,&nbsp;axes_manager])</td>
<td>Plot the signal at the current coordinates.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_factors</span></tt>([comp_ids,&nbsp;calibrate,&nbsp;...])</td>
<td>Plot factors from blind source separation results.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_loadings</span></tt>([comp_ids,&nbsp;calibrate,&nbsp;...])</td>
<td>Plot loadings from ICA</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_results</span></tt>([factors_navigator,&nbsp;...])</td>
<td>Plot the blind source separation factors and loadings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_cumulative_explained_variance_ratio</span></tt>([n])</td>
<td>Plot the principal components explained variance up to the</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_factors</span></tt>([comp_ids,&nbsp;...])</td>
<td>Plot factors from a decomposition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_loadings</span></tt>([comp_ids,&nbsp;...])</td>
<td>Plot loadings from PCA.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_results</span></tt>([...])</td>
<td>Plot the decompostion factors and loadings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_explained_variance_ratio</span></tt>([n,&nbsp;log])</td>
<td>Plot the decomposition explained variance ratio vs index number.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">print_summary_statistics</span></tt>([formatter])</td>
<td>Prints the five-number summary statistics of the data, the mean and the standard deviation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hyperspy._signals.eds.EDSSpectrum.rebin" title="hyperspy._signals.eds.EDSSpectrum.rebin"><tt class="xref py py-obj docutils literal"><span class="pre">rebin</span></tt></a>(new_shape)</td>
<td>Rebins the data to the new shape</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">remove_background</span></tt>([signal_range,&nbsp;...])</td>
<td>Remove the background, either in place using a gui or returned as a new spectrum using the command line.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse_bss_component</span></tt>(component_number)</td>
<td>Reverse the independent component</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse_decomposition_component</span></tt>(component_number)</td>
<td>Reverse the decomposition component</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">rollaxis</span></tt>(axis,&nbsp;to_axis)</td>
<td>Roll the specified axis backwards, until it lies in a given position.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">save</span></tt>([filename,&nbsp;overwrite,&nbsp;extension])</td>
<td>Saves the signal in the specified format.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hyperspy._signals.eds.EDSSpectrum.set_elements" title="hyperspy._signals.eds.EDSSpectrum.set_elements"><tt class="xref py py-obj docutils literal"><span class="pre">set_elements</span></tt></a>(elements)</td>
<td>Erase all elements and set them.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hyperspy._signals.eds.EDSSpectrum.set_lines" title="hyperspy._signals.eds.EDSSpectrum.set_lines"><tt class="xref py py-obj docutils literal"><span class="pre">set_lines</span></tt></a>(lines[,&nbsp;only_one,&nbsp;only_lines])</td>
<td>Erase all Xrays lines and set them.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_signal_origin</span></tt>(origin)</td>
<td>Set the origin of the signal and change the current class accordingly if pertinent.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_signal_type</span></tt>(signal_type)</td>
<td>Set the signal type and change the current class accordingly if pertinent.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">shift1D</span></tt>(shift_array[,&nbsp;interpolation_method,&nbsp;...])</td>
<td>Shift the data in place over the signal axis by the amount specified by an array.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_lowess</span></tt>([smoothing_parameter,&nbsp;...])</td>
<td>Lowess data smoothing in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_savitzky_golay</span></tt>([polynomial_order,&nbsp;...])</td>
<td>Apply a Savitzky-Golay filter to the data in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_tv</span></tt>([smoothing_parameter,&nbsp;...])</td>
<td>Total variation data smoothing in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">spikes_removal_tool</span></tt>([signal_mask,&nbsp;...])</td>
<td>Graphical interface to remove spikes from EELS spectra.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">split</span></tt>([axis,&nbsp;number_of_parts,&nbsp;step_sizes])</td>
<td>Splits the data into several signals.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">squeeze</span></tt>()</td>
<td>Remove single-dimensional entries from the shape of an array and the axes.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">std</span></tt>(axis)</td>
<td>Returns a signal with the standard deviation of the signal along an axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hyperspy._signals.eds.EDSSpectrum.sum" title="hyperspy._signals.eds.EDSSpectrum.sum"><tt class="xref py py-obj docutils literal"><span class="pre">sum</span></tt></a>(axis)</td>
<td>Sum the data over the given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">swap_axes</span></tt>(axis1,&nbsp;axis2)</td>
<td>Swaps the axes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_EDS</span></tt>([microscope])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_EELS</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_image</span></tt>()</td>
<td>Returns the spectrum as an image.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">undo_treatments</span></tt>()</td>
<td>Undo normalize_poissonian_noise</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold</span></tt>()</td>
<td>Modifies the shape of the data by unfolding the signal and</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_if_multidim</span></tt>()</td>
<td>Unfold the datacube if it is &gt;2D</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_navigation_space</span></tt>()</td>
<td>Modify the shape of the data to obtain a navigation space of</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_signal_space</span></tt>()</td>
<td>Modify the shape of the data to obtain a signal space of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">valuemax</span></tt>(axis)</td>
<td>Returns a signal with the value of the maximum along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">var</span></tt>(axis)</td>
<td>Returns a signal with the variances of the signal along an axis.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="hyperspy._signals.eds.EDSSpectrum.add_elements">
<tt class="descname">add_elements</tt><span class="sig-paren">(</span><em>elements</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDSSpectrum.add_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Add elements and the corresponding X-ray lines.</p>
<p>The list of elements is stored in <cite>metadata.Sample.elements</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elements</strong> : list of strings</p>
<blockquote class="last">
<div><p>The symbol of the elements.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#hyperspy._signals.eds.EDSSpectrum.set_elements" title="hyperspy._signals.eds.EDSSpectrum.set_elements"><tt class="xref py py-obj docutils literal"><span class="pre">set_elements</span></tt></a>, <a class="reference internal" href="#hyperspy._signals.eds.EDSSpectrum.add_lines" title="hyperspy._signals.eds.EDSSpectrum.add_lines"><tt class="xref py py-obj docutils literal"><span class="pre">add_lines</span></tt></a>, <tt class="xref py py-obj docutils literal"><span class="pre">set_lines.</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds.EDSSpectrum.add_lines">
<tt class="descname">add_lines</tt><span class="sig-paren">(</span><em>lines=()</em>, <em>only_one=True</em>, <em>only_lines=('Ka'</em>, <em>'La'</em>, <em>'Ma')</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDSSpectrum.add_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Add X-rays lines to the internal list.</p>
<p>Although most functions do not require an internal list of
X-ray lines because they can be calculated from the internal
list of elements, ocassionally it might be useful to customize the
X-ray lines to be use by all functions by default using this method.
The list of X-ray lines is stored in
<cite>metadata.Sample.xray_lines</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>lines</strong> : list of strings</p>
<blockquote>
<div><p>A list of valid element X-ray lines to add e.g. Fe_Kb.
Additionally, if <cite>metadata.Sample.elements</cite> is
defined, add the lines of those elements that where not
given in this list. If the list is empty (default), and
<cite>metadata.Sample.elements</cite> is
defined, add the lines of all those elements.</p>
</div></blockquote>
<p><strong>only_one: bool</strong> :</p>
<blockquote>
<div><p>If False, add all the lines of each element in
<cite>metadata.Sample.elements</cite> that has not line
defined in lines. If True (default),
only add the line at the highest energy
above an overvoltage of 2 (&lt; beam energy / 2).</p>
</div></blockquote>
<p><strong>only_lines</strong> : {None, list of strings}</p>
<blockquote class="last">
<div><p>If not None, only the given lines will be added.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#hyperspy._signals.eds.EDSSpectrum.set_lines" title="hyperspy._signals.eds.EDSSpectrum.set_lines"><tt class="xref py py-obj docutils literal"><span class="pre">set_lines</span></tt></a>, <a class="reference internal" href="#hyperspy._signals.eds.EDSSpectrum.add_elements" title="hyperspy._signals.eds.EDSSpectrum.add_elements"><tt class="xref py py-obj docutils literal"><span class="pre">add_elements</span></tt></a>, <tt class="xref py py-obj docutils literal"><span class="pre">set_elements.</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds.EDSSpectrum.get_lines_intensity">
<tt class="descname">get_lines_intensity</tt><span class="sig-paren">(</span><em>xray_lines=None</em>, <em>plot_result=False</em>, <em>integration_window_factor=2.0</em>, <em>only_one=True</em>, <em>only_lines=('Ka'</em>, <em>'La'</em>, <em>'Ma')</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDSSpectrum.get_lines_intensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the intensity map of selected Xray lines.</p>
<p>The intensities, the number of X-ray counts, are computed by
suming the spectrum over the
different X-ray lines. The sum window width
is calculated from the energy resolution of the detector
defined as defined in
<cite>self.metadata.Acquisition_instrument.SEM.Detector.EDS.energy_resolution_MnKa</cite>
or
<cite>self.metadata.Acquisition_instrument.SEM.Detector.EDS.energy_resolution_MnKa</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xray_lines: {None, &#8220;best&#8221;, list of string}</strong> :</p>
<blockquote>
<div><p>If None,
if <cite>mapped.parameters.Sample.elements.xray_lines</cite> contains a
list of lines use those.
If <cite>mapped.parameters.Sample.elements.xray_lines</cite> is undefined
or empty but <cite>mapped.parameters.Sample.elements</cite> is defined,
use the same syntax as <cite>add_line</cite> to select a subset of lines
for the operation.
Alternatively, provide an iterable containing
a list of valid X-ray lines symbols.</p>
</div></blockquote>
<p><strong>plot_result</strong> : bool</p>
<blockquote>
<div><p>If True, plot the calculated line intensities. If the current
object is a single spectrum it prints the result instead.</p>
</div></blockquote>
<p><strong>integration_window_factor: Float</strong> :</p>
<blockquote>
<div><p>The integration window is centered at the center of the X-ray
line and its width is defined by this factor (2 by default)
times the calculated FWHM of the line.</p>
</div></blockquote>
<p><strong>only_one</strong> : bool</p>
<blockquote>
<div><p>If False, use all the lines of each element in the data spectral
range. If True use only the line at the highest energy
above an overvoltage of 2 (&lt; beam energy / 2).</p>
</div></blockquote>
<p><strong>only_lines</strong> : {None, list of strings}</p>
<blockquote>
<div><p>If not None, use only the given lines.</p>
</div></blockquote>
<p><strong>kwargs</strong> :</p>
<blockquote>
<div><p>The extra keyword arguments for plotting. See
<cite>utils.plot.plot_signals</cite></p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>intensities</strong> : list</p>
<blockquote class="last">
<div><p>A list containing the intensities as Signal subclasses.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#hyperspy._signals.eds.EDSSpectrum.set_elements" title="hyperspy._signals.eds.EDSSpectrum.set_elements"><tt class="xref py py-obj docutils literal"><span class="pre">set_elements</span></tt></a>, <tt class="xref py py-obj docutils literal"><span class="pre">add_elements.</span></tt></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">specImg</span><span class="o">.</span><span class="n">get_lines_intensity</span><span class="p">([</span><span class="s">&quot;C_Ka&quot;</span><span class="p">,</span> <span class="s">&quot;Ta_Ma&quot;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds.EDSSpectrum.get_take_off_angle">
<tt class="descname">get_take_off_angle</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDSSpectrum.get_take_off_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the take-off-angle (TOA).</p>
<p>TOA is the angle with which the X-rays leave the surface towards
the detector. Parameters are read in &#8216;SEM.tilt_stage&#8217;,
&#8216;Acquisition_instrument.SEM.Detector.EDS.azimuth_angle&#8217; and
&#8216;SEM.Detector.EDS.elevation_angle&#8217; in &#8216;metadata&#8217;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>take_off_angle: float (Degree)</strong> :</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">utils.eds.take_off_angle</span></tt></p>
</div>
<p class="rubric">Notes</p>
<p>Defined by M. Schaffer et al., Ultramicroscopy 107(8), pp 587-597
(2007)</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds.EDSSpectrum.rebin">
<tt class="descname">rebin</tt><span class="sig-paren">(</span><em>new_shape</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDSSpectrum.rebin" title="Permalink to this definition">¶</a></dt>
<dd><p>Rebins the data to the new shape</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>new_shape: tuple of ints</strong> :</p>
<blockquote class="last">
<div><p>The new shape must be a divisor of the original shape</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds.EDSSpectrum.set_elements">
<tt class="descname">set_elements</tt><span class="sig-paren">(</span><em>elements</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDSSpectrum.set_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Erase all elements and set them.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elements</strong> : list of strings</p>
<blockquote class="last">
<div><p>A list of chemical element symbols.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#hyperspy._signals.eds.EDSSpectrum.add_elements" title="hyperspy._signals.eds.EDSSpectrum.add_elements"><tt class="xref py py-obj docutils literal"><span class="pre">add_elements</span></tt></a>, <tt class="xref py py-obj docutils literal"><span class="pre">set_line</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">add_lines.</span></tt></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">signals</span><span class="o">.</span><span class="n">EDSSEMSpectrum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1024</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">set_elements</span><span class="p">([</span><span class="s">&#39;Ni&#39;</span><span class="p">,</span> <span class="s">&#39;O&#39;</span><span class="p">],[</span><span class="s">&#39;Ka&#39;</span><span class="p">,</span><span class="s">&#39;Ka&#39;</span><span class="p">])</span>
<span class="go">Adding Ni_Ka Line</span>
<span class="go">Adding O_Ka Line</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">mapped_paramters</span><span class="o">.</span><span class="n">Acquisition_instrument</span><span class="o">.</span><span class="n">SEM</span><span class="o">.</span><span class="n">beam_energy</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">set_elements</span><span class="p">([</span><span class="s">&#39;Ni&#39;</span><span class="p">,</span> <span class="s">&#39;O&#39;</span><span class="p">])</span>
<span class="go">Adding Ni_La Line</span>
<span class="go">Adding O_Ka Line</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds.EDSSpectrum.set_lines">
<tt class="descname">set_lines</tt><span class="sig-paren">(</span><em>lines</em>, <em>only_one=True</em>, <em>only_lines=('Ka'</em>, <em>'La'</em>, <em>'Ma')</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDSSpectrum.set_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Erase all Xrays lines and set them.</p>
<p>See add_lines for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>lines</strong> : list of strings</p>
<blockquote>
<div><p>A list of valid element X-ray lines to add e.g. Fe_Kb.
Additionally, if <cite>metadata.Sample.elements</cite> is
defined, add the lines of those elements that where not
given in this list.</p>
</div></blockquote>
<p><strong>only_one: bool</strong> :</p>
<blockquote>
<div><p>If False, add all the lines of each element in
<cite>metadata.Sample.elements</cite> that has not line
defined in lines. If True (default),
only add the line at the highest energy
above an overvoltage of 2 (&lt; beam energy / 2).</p>
</div></blockquote>
<p><strong>only_lines</strong> : {None, list of strings}</p>
<blockquote class="last">
<div><p>If not None, only the given lines will be added.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#hyperspy._signals.eds.EDSSpectrum.add_lines" title="hyperspy._signals.eds.EDSSpectrum.add_lines"><tt class="xref py py-obj docutils literal"><span class="pre">add_lines</span></tt></a>, <a class="reference internal" href="#hyperspy._signals.eds.EDSSpectrum.add_elements" title="hyperspy._signals.eds.EDSSpectrum.add_elements"><tt class="xref py py-obj docutils literal"><span class="pre">add_elements</span></tt></a>, <tt class="xref py py-obj docutils literal"><span class="pre">set_elements..</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds.EDSSpectrum.sum">
<tt class="descname">sum</tt><span class="sig-paren">(</span><em>axis</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds.EDSSpectrum.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum the data over the given axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>axis</strong> : {int, string}</p>
<blockquote>
<div><p>The axis can be specified using the index of the axis in
<cite>axes_manager</cite> or the axis name.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>s</strong> : Signal</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">sum_in_mask</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">mean</span></tt></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">64</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">1024</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64,1024)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64,64)</span>
<span class="go"># If we just want to plot the result of the operation</span>
<span class="go">s.sum(-1, True).plot()</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.eds_sem">
<span id="hyperspy-signals-eds-sem-module"></span><h2>hyperspy._signals.eds_sem module<a class="headerlink" href="#module-hyperspy._signals.eds_sem" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.eds_sem.EDSSEMSpectrum">
<em class="property">class </em><tt class="descclassname">hyperspy._signals.eds_sem.</tt><tt class="descname">EDSSEMSpectrum</tt><span class="sig-paren">(</span><em>*args</em>, <em>**kwards</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_sem.EDSSEMSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.eds.EDSSpectrum" title="hyperspy._signals.eds.EDSSpectrum"><tt class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.eds.EDSSpectrum</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">add_elements</span></tt>(elements)</td>
<td>Add elements and the corresponding X-ray lines.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">add_lines</span></tt>([lines,&nbsp;only_one,&nbsp;only_lines])</td>
<td>Add X-rays lines to the internal list.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">align1D</span></tt>([start,&nbsp;end,&nbsp;reference_indices,&nbsp;...])</td>
<td>Estimate the shifts in the signal axis using cross-correlation and use the estimation to align the data in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">align2D</span></tt>([crop,&nbsp;fill_value,&nbsp;shifts,&nbsp;roi,&nbsp;...])</td>
<td>Align the images in place using user provided shifts or by estimating the shifts.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">anscombe</span></tt>()</td>
<td>Anscombe transform.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">anscombe_inverse</span></tt>([method])</td>
<td>Inverse anscombe transform.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_image</span></tt>(image_axes)</td>
<td>Convert signal to image.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_spectrum</span></tt>(spectral_axis)</td>
<td>Return the Signal as a spectrum.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">blind_source_separation</span></tt>([...])</td>
<td>Blind source separation (BSS) on the result on the decomposition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">calibrate</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Calibrate the spectral dimension using a gui.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_dtype</span></tt>(dtype)</td>
<td>Change the data type.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop</span></tt>(axis[,&nbsp;start,&nbsp;end])</td>
<td>Crops the data in a given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop_image</span></tt>([top,&nbsp;bottom,&nbsp;left,&nbsp;right])</td>
<td>Crops an image in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop_spectrum</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Crop in place the spectral dimension.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">decomposition</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Decomposition with a choice of algorithms</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">deepcopy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">diff</span></tt>(axis[,&nbsp;order])</td>
<td>Returns a signal with the n-th order discrete difference along given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_peak_width</span></tt>([factor,&nbsp;window,&nbsp;...])</td>
<td>Estimate the width of the highest intensity of peak of the spectra at a given fraction of its maximum.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_poissonian_noise_variance</span></tt>([...])</td>
<td>Estimate the poissonian noise variance of the signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift1D</span></tt>([start,&nbsp;end,&nbsp;...])</td>
<td>Estimate the shifts in the current signal axis using  cross-correlation.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift2D</span></tt>([reference,&nbsp;...])</td>
<td>Estimate the shifts in a image using phase correlation</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">export_bss_results</span></tt>([comp_ids,&nbsp;folder,&nbsp;...])</td>
<td>Export results from ICA to any of the supported formats.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">export_decomposition_results</span></tt>([comp_ids,&nbsp;...])</td>
<td>Export results from a decomposition to any of the supported formats.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">filter_butterworth</span></tt>([cutoff_frequency_ratio,&nbsp;...])</td>
<td>Butterworth filter in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">find_peaks1D_ohaver</span></tt>([xdim,&nbsp;slope_thresh,&nbsp;...])</td>
<td>Find peaks along a 1D line (peaks in spectrum/spectra).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">fold</span></tt>(*args,&nbsp;**kwargs)</td>
<td>If the signal was previously unfolded, folds it back</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">gaussian_filter</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Applies a Gaussian filter in the spectral dimension in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_factors</span></tt>()</td>
<td>Return the blind source separtion factors as a Signal.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_loadings</span></tt>()</td>
<td>Return the blind source separtion loadings as a Signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_model</span></tt>([components])</td>
<td>Return the spectrum generated with the selected number of</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hyperspy._signals.eds_sem.EDSSEMSpectrum.get_calibration_from" title="hyperspy._signals.eds_sem.EDSSEMSpectrum.get_calibration_from"><tt class="xref py py-obj docutils literal"><span class="pre">get_calibration_from</span></tt></a>(ref[,&nbsp;nb_pix])</td>
<td>Copy the calibration and all metadata of a reference.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_current_signal</span></tt>([auto_title,&nbsp;auto_filename])</td>
<td>Returns the data at the current coordinates as a Signal subclass.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_factors</span></tt>()</td>
<td>Return the decomposition factors as a Signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_loadings</span></tt>()</td>
<td>Return the decomposition loadings as a Signal.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_model</span></tt>([components])</td>
<td>Return the spectrum generated with the selected number of principal</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_dimensions_from_data</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Get the dimension parameters from the data_cube.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_explained_variance_ratio</span></tt>()</td>
<td>Return the explained variation ratio of the PCA components as a Spectrum.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_histogram</span></tt>(img[,&nbsp;bins,&nbsp;range_bins])</td>
<td>Return a histogram of the signal data.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_lines_intensity</span></tt>([xray_lines,&nbsp;...])</td>
<td>Return the intensity map of selected Xray lines.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_take_off_angle</span></tt>()</td>
<td>Calculate the take-off-angle (TOA).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">hanning_taper</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Apply a hanning taper to the data in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">indexmax</span></tt>(axis)</td>
<td>Returns a signal with the index of the maximum along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate1D</span></tt>(axis)</td>
<td>Integrate the signal over the given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate_in_range</span></tt>([signal_range])</td>
<td>Sums the spectrum over an energy range, giving the integrated area.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate_simpson</span></tt>(axis)</td>
<td>Returns a signal with the result of calculating the integral of the signal along an axis using Simpson&#8217;s rule.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">interpolate_in_between</span></tt>(start,&nbsp;end[,&nbsp;delta,&nbsp;...])</td>
<td>Replace the data in a given range by interpolation.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">map</span></tt>(function[,&nbsp;show_progressbar])</td>
<td>Apply a function to the signal data at all the coordinates.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">max</span></tt>(axis[,&nbsp;return_signal])</td>
<td>Returns a signal with the maximum of the signal along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">mean</span></tt>(axis)</td>
<td>Returns a signal with the average of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">min</span></tt>(axis)</td>
<td>Returns a signal with the minimum of the signal along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">next</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">normalize_factors</span></tt>([which,&nbsp;by,&nbsp;sort])</td>
<td>Normalises the factors and modifies the loadings</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">normalize_poissonian_noise</span></tt>([...])</td>
<td>Scales the SI following Surf.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot</span></tt>([navigator,&nbsp;axes_manager])</td>
<td>Plot the signal at the current coordinates.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_factors</span></tt>([comp_ids,&nbsp;calibrate,&nbsp;...])</td>
<td>Plot factors from blind source separation results.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_loadings</span></tt>([comp_ids,&nbsp;calibrate,&nbsp;...])</td>
<td>Plot loadings from ICA</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_results</span></tt>([factors_navigator,&nbsp;...])</td>
<td>Plot the blind source separation factors and loadings.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_cumulative_explained_variance_ratio</span></tt>([n])</td>
<td>Plot the principal components explained variance up to the</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_factors</span></tt>([comp_ids,&nbsp;...])</td>
<td>Plot factors from a decomposition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_loadings</span></tt>([comp_ids,&nbsp;...])</td>
<td>Plot loadings from PCA.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_results</span></tt>([...])</td>
<td>Plot the decompostion factors and loadings.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_explained_variance_ratio</span></tt>([n,&nbsp;log])</td>
<td>Plot the decomposition explained variance ratio vs index number.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">print_summary_statistics</span></tt>([formatter])</td>
<td>Prints the five-number summary statistics of the data, the mean and the standard deviation.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">rebin</span></tt>(new_shape)</td>
<td>Rebins the data to the new shape</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">remove_background</span></tt>([signal_range,&nbsp;...])</td>
<td>Remove the background, either in place using a gui or returned as a new spectrum using the command line.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse_bss_component</span></tt>(component_number)</td>
<td>Reverse the independent component</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse_decomposition_component</span></tt>(component_number)</td>
<td>Reverse the decomposition component</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">rollaxis</span></tt>(axis,&nbsp;to_axis)</td>
<td>Roll the specified axis backwards, until it lies in a given position.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">save</span></tt>([filename,&nbsp;overwrite,&nbsp;extension])</td>
<td>Saves the signal in the specified format.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_elements</span></tt>(elements)</td>
<td>Erase all elements and set them.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_lines</span></tt>(lines[,&nbsp;only_one,&nbsp;only_lines])</td>
<td>Erase all Xrays lines and set them.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hyperspy._signals.eds_sem.EDSSEMSpectrum.set_microscope_parameters" title="hyperspy._signals.eds_sem.EDSSEMSpectrum.set_microscope_parameters"><tt class="xref py py-obj docutils literal"><span class="pre">set_microscope_parameters</span></tt></a>([beam_energy,&nbsp;...])</td>
<td>Set the microscope parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_signal_origin</span></tt>(origin)</td>
<td>Set the origin of the signal and change the current class accordingly if pertinent.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_signal_type</span></tt>(signal_type)</td>
<td>Set the signal type and change the current class accordingly if pertinent.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">shift1D</span></tt>(shift_array[,&nbsp;interpolation_method,&nbsp;...])</td>
<td>Shift the data in place over the signal axis by the amount specified by an array.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_lowess</span></tt>([smoothing_parameter,&nbsp;...])</td>
<td>Lowess data smoothing in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_savitzky_golay</span></tt>([polynomial_order,&nbsp;...])</td>
<td>Apply a Savitzky-Golay filter to the data in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_tv</span></tt>([smoothing_parameter,&nbsp;...])</td>
<td>Total variation data smoothing in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">spikes_removal_tool</span></tt>([signal_mask,&nbsp;...])</td>
<td>Graphical interface to remove spikes from EELS spectra.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">split</span></tt>([axis,&nbsp;number_of_parts,&nbsp;step_sizes])</td>
<td>Splits the data into several signals.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">squeeze</span></tt>()</td>
<td>Remove single-dimensional entries from the shape of an array and the axes.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">std</span></tt>(axis)</td>
<td>Returns a signal with the standard deviation of the signal along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">sum</span></tt>(axis)</td>
<td>Sum the data over the given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">swap_axes</span></tt>(axis1,&nbsp;axis2)</td>
<td>Swaps the axes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_EDS</span></tt>([microscope])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_EELS</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_image</span></tt>()</td>
<td>Returns the spectrum as an image.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">undo_treatments</span></tt>()</td>
<td>Undo normalize_poissonian_noise</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold</span></tt>()</td>
<td>Modifies the shape of the data by unfolding the signal and</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_if_multidim</span></tt>()</td>
<td>Unfold the datacube if it is &gt;2D</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_navigation_space</span></tt>()</td>
<td>Modify the shape of the data to obtain a navigation space of</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_signal_space</span></tt>()</td>
<td>Modify the shape of the data to obtain a signal space of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">valuemax</span></tt>(axis)</td>
<td>Returns a signal with the value of the maximum along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">var</span></tt>(axis)</td>
<td>Returns a signal with the variances of the signal along an axis.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="hyperspy._signals.eds_sem.EDSSEMSpectrum.get_calibration_from">
<tt class="descname">get_calibration_from</tt><span class="sig-paren">(</span><em>ref</em>, <em>nb_pix=1</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_sem.EDSSEMSpectrum.get_calibration_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the calibration and all metadata of a reference.</p>
<p>Primary use: To add a calibration to ripple file from INCA
software</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref</strong> : signal</p>
<blockquote>
<div><p>The reference contains the calibration in its
metadata</p>
</div></blockquote>
<p><strong>nb_pix</strong> : int</p>
<blockquote class="last">
<div><p>The live time (real time corrected from the &#8220;dead time&#8221;)
is divided by the number of pixel (spectrums), giving an
average live time.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds_sem.EDSSEMSpectrum.set_microscope_parameters">
<tt class="descname">set_microscope_parameters</tt><span class="sig-paren">(</span><em>beam_energy=None</em>, <em>live_time=None</em>, <em>tilt_stage=None</em>, <em>azimuth_angle=None</em>, <em>elevation_angle=None</em>, <em>energy_resolution_MnKa=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_sem.EDSSEMSpectrum.set_microscope_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the microscope parameters.</p>
<p>If no arguments are given, raises an interactive mode to fill
the values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>beam_energy: float</strong> :</p>
<blockquote>
<div><p>The energy of the electron beam in keV</p>
</div></blockquote>
<p><strong>live_time</strong> : float</p>
<blockquote>
<div><p>In second</p>
</div></blockquote>
<p><strong>tilt_stage</strong> : float</p>
<blockquote>
<div><p>In degree</p>
</div></blockquote>
<p><strong>azimuth_angle</strong> : float</p>
<blockquote>
<div><p>In degree</p>
</div></blockquote>
<p><strong>elevation_angle</strong> : float</p>
<blockquote>
<div><p>In degree</p>
</div></blockquote>
<p><strong>energy_resolution_MnKa</strong> : float</p>
<blockquote class="last">
<div><p>In eV</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.eds_tem">
<span id="hyperspy-signals-eds-tem-module"></span><h2>hyperspy._signals.eds_tem module<a class="headerlink" href="#module-hyperspy._signals.eds_tem" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.eds_tem.EDSTEMSpectrum">
<em class="property">class </em><tt class="descclassname">hyperspy._signals.eds_tem.</tt><tt class="descname">EDSTEMSpectrum</tt><span class="sig-paren">(</span><em>*args</em>, <em>**kwards</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_tem.EDSTEMSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.eds.EDSSpectrum" title="hyperspy._signals.eds.EDSSpectrum"><tt class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.eds.EDSSpectrum</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">add_elements</span></tt>(elements)</td>
<td>Add elements and the corresponding X-ray lines.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">add_lines</span></tt>([lines,&nbsp;only_one,&nbsp;only_lines])</td>
<td>Add X-rays lines to the internal list.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">align1D</span></tt>([start,&nbsp;end,&nbsp;reference_indices,&nbsp;...])</td>
<td>Estimate the shifts in the signal axis using cross-correlation and use the estimation to align the data in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">align2D</span></tt>([crop,&nbsp;fill_value,&nbsp;shifts,&nbsp;roi,&nbsp;...])</td>
<td>Align the images in place using user provided shifts or by estimating the shifts.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">anscombe</span></tt>()</td>
<td>Anscombe transform.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">anscombe_inverse</span></tt>([method])</td>
<td>Inverse anscombe transform.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_image</span></tt>(image_axes)</td>
<td>Convert signal to image.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_spectrum</span></tt>(spectral_axis)</td>
<td>Return the Signal as a spectrum.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">blind_source_separation</span></tt>([...])</td>
<td>Blind source separation (BSS) on the result on the decomposition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">calibrate</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Calibrate the spectral dimension using a gui.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_dtype</span></tt>(dtype)</td>
<td>Change the data type.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop</span></tt>(axis[,&nbsp;start,&nbsp;end])</td>
<td>Crops the data in a given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop_image</span></tt>([top,&nbsp;bottom,&nbsp;left,&nbsp;right])</td>
<td>Crops an image in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop_spectrum</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Crop in place the spectral dimension.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">decomposition</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Decomposition with a choice of algorithms</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">deepcopy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">diff</span></tt>(axis[,&nbsp;order])</td>
<td>Returns a signal with the n-th order discrete difference along given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_peak_width</span></tt>([factor,&nbsp;window,&nbsp;...])</td>
<td>Estimate the width of the highest intensity of peak of the spectra at a given fraction of its maximum.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_poissonian_noise_variance</span></tt>([...])</td>
<td>Estimate the poissonian noise variance of the signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift1D</span></tt>([start,&nbsp;end,&nbsp;...])</td>
<td>Estimate the shifts in the current signal axis using  cross-correlation.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift2D</span></tt>([reference,&nbsp;...])</td>
<td>Estimate the shifts in a image using phase correlation</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">export_bss_results</span></tt>([comp_ids,&nbsp;folder,&nbsp;...])</td>
<td>Export results from ICA to any of the supported formats.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">export_decomposition_results</span></tt>([comp_ids,&nbsp;...])</td>
<td>Export results from a decomposition to any of the supported formats.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">filter_butterworth</span></tt>([cutoff_frequency_ratio,&nbsp;...])</td>
<td>Butterworth filter in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">find_peaks1D_ohaver</span></tt>([xdim,&nbsp;slope_thresh,&nbsp;...])</td>
<td>Find peaks along a 1D line (peaks in spectrum/spectra).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">fold</span></tt>(*args,&nbsp;**kwargs)</td>
<td>If the signal was previously unfolded, folds it back</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">gaussian_filter</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Applies a Gaussian filter in the spectral dimension in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_factors</span></tt>()</td>
<td>Return the blind source separtion factors as a Signal.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_loadings</span></tt>()</td>
<td>Return the blind source separtion loadings as a Signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_model</span></tt>([components])</td>
<td>Return the spectrum generated with the selected number of</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hyperspy._signals.eds_tem.EDSTEMSpectrum.get_calibration_from" title="hyperspy._signals.eds_tem.EDSTEMSpectrum.get_calibration_from"><tt class="xref py py-obj docutils literal"><span class="pre">get_calibration_from</span></tt></a>(ref[,&nbsp;nb_pix])</td>
<td>Copy the calibration and all metadata of a reference.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_current_signal</span></tt>([auto_title,&nbsp;auto_filename])</td>
<td>Returns the data at the current coordinates as a Signal subclass.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_factors</span></tt>()</td>
<td>Return the decomposition factors as a Signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_loadings</span></tt>()</td>
<td>Return the decomposition loadings as a Signal.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_model</span></tt>([components])</td>
<td>Return the spectrum generated with the selected number of principal</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_dimensions_from_data</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Get the dimension parameters from the data_cube.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_explained_variance_ratio</span></tt>()</td>
<td>Return the explained variation ratio of the PCA components as a Spectrum.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_histogram</span></tt>(img[,&nbsp;bins,&nbsp;range_bins])</td>
<td>Return a histogram of the signal data.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_lines_intensity</span></tt>([xray_lines,&nbsp;...])</td>
<td>Return the intensity map of selected Xray lines.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_take_off_angle</span></tt>()</td>
<td>Calculate the take-off-angle (TOA).</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">hanning_taper</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Apply a hanning taper to the data in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">indexmax</span></tt>(axis)</td>
<td>Returns a signal with the index of the maximum along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate1D</span></tt>(axis)</td>
<td>Integrate the signal over the given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate_in_range</span></tt>([signal_range])</td>
<td>Sums the spectrum over an energy range, giving the integrated area.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate_simpson</span></tt>(axis)</td>
<td>Returns a signal with the result of calculating the integral of the signal along an axis using Simpson&#8217;s rule.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">interpolate_in_between</span></tt>(start,&nbsp;end[,&nbsp;delta,&nbsp;...])</td>
<td>Replace the data in a given range by interpolation.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">map</span></tt>(function[,&nbsp;show_progressbar])</td>
<td>Apply a function to the signal data at all the coordinates.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">max</span></tt>(axis[,&nbsp;return_signal])</td>
<td>Returns a signal with the maximum of the signal along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">mean</span></tt>(axis)</td>
<td>Returns a signal with the average of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">min</span></tt>(axis)</td>
<td>Returns a signal with the minimum of the signal along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">next</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">normalize_factors</span></tt>([which,&nbsp;by,&nbsp;sort])</td>
<td>Normalises the factors and modifies the loadings</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">normalize_poissonian_noise</span></tt>([...])</td>
<td>Scales the SI following Surf.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot</span></tt>([navigator,&nbsp;axes_manager])</td>
<td>Plot the signal at the current coordinates.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_factors</span></tt>([comp_ids,&nbsp;calibrate,&nbsp;...])</td>
<td>Plot factors from blind source separation results.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_loadings</span></tt>([comp_ids,&nbsp;calibrate,&nbsp;...])</td>
<td>Plot loadings from ICA</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_results</span></tt>([factors_navigator,&nbsp;...])</td>
<td>Plot the blind source separation factors and loadings.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_cumulative_explained_variance_ratio</span></tt>([n])</td>
<td>Plot the principal components explained variance up to the</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_factors</span></tt>([comp_ids,&nbsp;...])</td>
<td>Plot factors from a decomposition.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_loadings</span></tt>([comp_ids,&nbsp;...])</td>
<td>Plot loadings from PCA.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_results</span></tt>([...])</td>
<td>Plot the decompostion factors and loadings.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_explained_variance_ratio</span></tt>([n,&nbsp;log])</td>
<td>Plot the decomposition explained variance ratio vs index number.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">print_summary_statistics</span></tt>([formatter])</td>
<td>Prints the five-number summary statistics of the data, the mean and the standard deviation.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">rebin</span></tt>(new_shape)</td>
<td>Rebins the data to the new shape</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">remove_background</span></tt>([signal_range,&nbsp;...])</td>
<td>Remove the background, either in place using a gui or returned as a new spectrum using the command line.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse_bss_component</span></tt>(component_number)</td>
<td>Reverse the independent component</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse_decomposition_component</span></tt>(component_number)</td>
<td>Reverse the decomposition component</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">rollaxis</span></tt>(axis,&nbsp;to_axis)</td>
<td>Roll the specified axis backwards, until it lies in a given position.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">save</span></tt>([filename,&nbsp;overwrite,&nbsp;extension])</td>
<td>Saves the signal in the specified format.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_elements</span></tt>(elements)</td>
<td>Erase all elements and set them.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_lines</span></tt>(lines[,&nbsp;only_one,&nbsp;only_lines])</td>
<td>Erase all Xrays lines and set them.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hyperspy._signals.eds_tem.EDSTEMSpectrum.set_microscope_parameters" title="hyperspy._signals.eds_tem.EDSTEMSpectrum.set_microscope_parameters"><tt class="xref py py-obj docutils literal"><span class="pre">set_microscope_parameters</span></tt></a>([beam_energy,&nbsp;...])</td>
<td>Set the microscope parameters.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_signal_origin</span></tt>(origin)</td>
<td>Set the origin of the signal and change the current class accordingly if pertinent.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_signal_type</span></tt>(signal_type)</td>
<td>Set the signal type and change the current class accordingly if pertinent.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">shift1D</span></tt>(shift_array[,&nbsp;interpolation_method,&nbsp;...])</td>
<td>Shift the data in place over the signal axis by the amount specified by an array.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_lowess</span></tt>([smoothing_parameter,&nbsp;...])</td>
<td>Lowess data smoothing in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_savitzky_golay</span></tt>([polynomial_order,&nbsp;...])</td>
<td>Apply a Savitzky-Golay filter to the data in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_tv</span></tt>([smoothing_parameter,&nbsp;...])</td>
<td>Total variation data smoothing in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">spikes_removal_tool</span></tt>([signal_mask,&nbsp;...])</td>
<td>Graphical interface to remove spikes from EELS spectra.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">split</span></tt>([axis,&nbsp;number_of_parts,&nbsp;step_sizes])</td>
<td>Splits the data into several signals.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">squeeze</span></tt>()</td>
<td>Remove single-dimensional entries from the shape of an array and the axes.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">std</span></tt>(axis)</td>
<td>Returns a signal with the standard deviation of the signal along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">sum</span></tt>(axis)</td>
<td>Sum the data over the given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">swap_axes</span></tt>(axis1,&nbsp;axis2)</td>
<td>Swaps the axes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_EDS</span></tt>([microscope])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_EELS</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_image</span></tt>()</td>
<td>Returns the spectrum as an image.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">undo_treatments</span></tt>()</td>
<td>Undo normalize_poissonian_noise</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold</span></tt>()</td>
<td>Modifies the shape of the data by unfolding the signal and</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_if_multidim</span></tt>()</td>
<td>Unfold the datacube if it is &gt;2D</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_navigation_space</span></tt>()</td>
<td>Modify the shape of the data to obtain a navigation space of</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_signal_space</span></tt>()</td>
<td>Modify the shape of the data to obtain a signal space of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">valuemax</span></tt>(axis)</td>
<td>Returns a signal with the value of the maximum along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">var</span></tt>(axis)</td>
<td>Returns a signal with the variances of the signal along an axis.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="hyperspy._signals.eds_tem.EDSTEMSpectrum.get_calibration_from">
<tt class="descname">get_calibration_from</tt><span class="sig-paren">(</span><em>ref</em>, <em>nb_pix=1</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_tem.EDSTEMSpectrum.get_calibration_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the calibration and all metadata of a reference.</p>
<p>Primary use: To add a calibration to ripple file from INCA
software</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref</strong> : signal</p>
<blockquote>
<div><p>The reference contains the calibration in its
metadata</p>
</div></blockquote>
<p><strong>nb_pix</strong> : int</p>
<blockquote class="last">
<div><p>The live time (real time corrected from the &#8220;dead time&#8221;)
is divided by the number of pixel (spectrums), giving an
average live time.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eds_tem.EDSTEMSpectrum.set_microscope_parameters">
<tt class="descname">set_microscope_parameters</tt><span class="sig-paren">(</span><em>beam_energy=None</em>, <em>live_time=None</em>, <em>tilt_stage=None</em>, <em>azimuth_angle=None</em>, <em>elevation_angle=None</em>, <em>energy_resolution_MnKa=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eds_tem.EDSTEMSpectrum.set_microscope_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the microscope parameters.</p>
<p>If no arguments are given, raises an interactive mode to fill
the values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>beam_energy: float</strong> :</p>
<blockquote>
<div><p>The energy of the electron beam in keV</p>
</div></blockquote>
<p><strong>live_time</strong> : float</p>
<blockquote>
<div><p>In second</p>
</div></blockquote>
<p><strong>tilt_stage</strong> : float</p>
<blockquote>
<div><p>In degree</p>
</div></blockquote>
<p><strong>azimuth_angle</strong> : float</p>
<blockquote>
<div><p>In degree</p>
</div></blockquote>
<p><strong>elevation_angle</strong> : float</p>
<blockquote>
<div><p>In degree</p>
</div></blockquote>
<p><strong>energy_resolution_MnKa</strong> : float</p>
<blockquote class="last">
<div><p>In eV</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.eels">
<span id="hyperspy-signals-eels-module"></span><h2>hyperspy._signals.eels module<a class="headerlink" href="#module-hyperspy._signals.eels" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.eels.EELSSpectrum">
<em class="property">class </em><tt class="descclassname">hyperspy._signals.eels.</tt><tt class="descname">EELSSpectrum</tt><span class="sig-paren">(</span><em>*args</em>, <em>**kwards</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.spectrum.Spectrum" title="hyperspy._signals.spectrum.Spectrum"><tt class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.spectrum.Spectrum</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum.add_elements" title="hyperspy._signals.eels.EELSSpectrum.add_elements"><tt class="xref py py-obj docutils literal"><span class="pre">add_elements</span></tt></a>(elements[,&nbsp;include_pre_edges])</td>
<td>Declare the elemental composition of the sample.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">align1D</span></tt>([start,&nbsp;end,&nbsp;reference_indices,&nbsp;...])</td>
<td>Estimate the shifts in the signal axis using cross-correlation and use the estimation to align the data in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">align2D</span></tt>([crop,&nbsp;fill_value,&nbsp;shifts,&nbsp;roi,&nbsp;...])</td>
<td>Align the images in place using user provided shifts or by estimating the shifts.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum.align_zero_loss_peak" title="hyperspy._signals.eels.EELSSpectrum.align_zero_loss_peak"><tt class="xref py py-obj docutils literal"><span class="pre">align_zero_loss_peak</span></tt></a>([calibrate,&nbsp;...])</td>
<td>Align the zero-loss peak.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">anscombe</span></tt>()</td>
<td>Anscombe transform.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">anscombe_inverse</span></tt>([method])</td>
<td>Inverse anscombe transform.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_image</span></tt>(image_axes)</td>
<td>Convert signal to image.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_spectrum</span></tt>(spectral_axis)</td>
<td>Return the Signal as a spectrum.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">blind_source_separation</span></tt>([...])</td>
<td>Blind source separation (BSS) on the result on the decomposition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">calibrate</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Calibrate the spectral dimension using a gui.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_dtype</span></tt>(dtype)</td>
<td>Change the data type.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop</span></tt>(axis[,&nbsp;start,&nbsp;end])</td>
<td>Crops the data in a given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop_image</span></tt>([top,&nbsp;bottom,&nbsp;left,&nbsp;right])</td>
<td>Crops an image in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop_spectrum</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Crop in place the spectral dimension.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">decomposition</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Decomposition with a choice of algorithms</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">deepcopy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">diff</span></tt>(axis[,&nbsp;order])</td>
<td>Returns a signal with the n-th order discrete difference along given axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum.estimate_elastic_scattering_intensity" title="hyperspy._signals.eels.EELSSpectrum.estimate_elastic_scattering_intensity"><tt class="xref py py-obj docutils literal"><span class="pre">estimate_elastic_scattering_intensity</span></tt></a>(threshold)</td>
<td>Rough estimation of the elastic scattering intensity by truncation of a EELS low-loss spectrum.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum.estimate_elastic_scattering_threshold" title="hyperspy._signals.eels.EELSSpectrum.estimate_elastic_scattering_threshold"><tt class="xref py py-obj docutils literal"><span class="pre">estimate_elastic_scattering_threshold</span></tt></a>([...])</td>
<td>Calculate the first inflexion point of the spectrum derivative within a window.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_peak_width</span></tt>([factor,&nbsp;window,&nbsp;...])</td>
<td>Estimate the width of the highest intensity of peak of the spectra at a given fraction of its maximum.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_poissonian_noise_variance</span></tt>([...])</td>
<td>Estimate the poissonian noise variance of the signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift1D</span></tt>([start,&nbsp;end,&nbsp;...])</td>
<td>Estimate the shifts in the current signal axis using  cross-correlation.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift2D</span></tt>([reference,&nbsp;...])</td>
<td>Estimate the shifts in a image using phase correlation</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum.estimate_thickness" title="hyperspy._signals.eels.EELSSpectrum.estimate_thickness"><tt class="xref py py-obj docutils literal"><span class="pre">estimate_thickness</span></tt></a>(threshold[,&nbsp;zlp])</td>
<td>Estimates the thickness (relative to the mean free path) of a sample using the log-ratio method.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum.estimate_zero_loss_peak_centre" title="hyperspy._signals.eels.EELSSpectrum.estimate_zero_loss_peak_centre"><tt class="xref py py-obj docutils literal"><span class="pre">estimate_zero_loss_peak_centre</span></tt></a>([mask])</td>
<td>Estimate the posision of the zero-loss peak.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">export_bss_results</span></tt>([comp_ids,&nbsp;folder,&nbsp;...])</td>
<td>Export results from ICA to any of the supported formats.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">export_decomposition_results</span></tt>([comp_ids,&nbsp;...])</td>
<td>Export results from a decomposition to any of the supported formats.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">filter_butterworth</span></tt>([cutoff_frequency_ratio,&nbsp;...])</td>
<td>Butterworth filter in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">find_peaks1D_ohaver</span></tt>([xdim,&nbsp;slope_thresh,&nbsp;...])</td>
<td>Find peaks along a 1D line (peaks in spectrum/spectra).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">fold</span></tt>(*args,&nbsp;**kwargs)</td>
<td>If the signal was previously unfolded, folds it back</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum.fourier_log_deconvolution" title="hyperspy._signals.eels.EELSSpectrum.fourier_log_deconvolution"><tt class="xref py py-obj docutils literal"><span class="pre">fourier_log_deconvolution</span></tt></a>(zlp[,&nbsp;add_zlp,&nbsp;crop])</td>
<td>Performs fourier-log deconvolution.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum.fourier_ratio_deconvolution" title="hyperspy._signals.eels.EELSSpectrum.fourier_ratio_deconvolution"><tt class="xref py py-obj docutils literal"><span class="pre">fourier_ratio_deconvolution</span></tt></a>(ll[,&nbsp;fwhm,&nbsp;...])</td>
<td>Performs Fourier-ratio deconvolution.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">gaussian_filter</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Applies a Gaussian filter in the spectral dimension in place.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum.generate_subshells" title="hyperspy._signals.eels.EELSSpectrum.generate_subshells"><tt class="xref py py-obj docutils literal"><span class="pre">generate_subshells</span></tt></a>([include_pre_edges])</td>
<td>Calculate the subshells for the current energy range for the</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_factors</span></tt>()</td>
<td>Return the blind source separtion factors as a Signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_loadings</span></tt>()</td>
<td>Return the blind source separtion loadings as a Signal.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_model</span></tt>([components])</td>
<td>Return the spectrum generated with the selected number of</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_current_signal</span></tt>([auto_title,&nbsp;auto_filename])</td>
<td>Returns the data at the current coordinates as a Signal subclass.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_factors</span></tt>()</td>
<td>Return the decomposition factors as a Signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_loadings</span></tt>()</td>
<td>Return the decomposition loadings as a Signal.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_model</span></tt>([components])</td>
<td>Return the spectrum generated with the selected number of principal</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_dimensions_from_data</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Get the dimension parameters from the data_cube.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_explained_variance_ratio</span></tt>()</td>
<td>Return the explained variation ratio of the PCA components as a Spectrum.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_histogram</span></tt>(img[,&nbsp;bins,&nbsp;range_bins])</td>
<td>Return a histogram of the signal data.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">hanning_taper</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Apply a hanning taper to the data in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">indexmax</span></tt>(axis)</td>
<td>Returns a signal with the index of the maximum along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate1D</span></tt>(axis)</td>
<td>Integrate the signal over the given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate_in_range</span></tt>([signal_range])</td>
<td>Sums the spectrum over an energy range, giving the integrated area.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate_simpson</span></tt>(axis)</td>
<td>Returns a signal with the result of calculating the integral of the signal along an axis using Simpson&#8217;s rule.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">interpolate_in_between</span></tt>(start,&nbsp;end[,&nbsp;delta,&nbsp;...])</td>
<td>Replace the data in a given range by interpolation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum.kramers_kronig_analysis" title="hyperspy._signals.eels.EELSSpectrum.kramers_kronig_analysis"><tt class="xref py py-obj docutils literal"><span class="pre">kramers_kronig_analysis</span></tt></a>([zlp,&nbsp;iterations,&nbsp;...])</td>
<td>Calculate the complex dielectric function from a single scattering distribution (SSD) using the Kramers-Kronig relations.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">map</span></tt>(function[,&nbsp;show_progressbar])</td>
<td>Apply a function to the signal data at all the coordinates.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">max</span></tt>(axis[,&nbsp;return_signal])</td>
<td>Returns a signal with the maximum of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">mean</span></tt>(axis)</td>
<td>Returns a signal with the average of the signal along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">min</span></tt>(axis)</td>
<td>Returns a signal with the minimum of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">next</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">normalize_factors</span></tt>([which,&nbsp;by,&nbsp;sort])</td>
<td>Normalises the factors and modifies the loadings</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">normalize_poissonian_noise</span></tt>([...])</td>
<td>Scales the SI following Surf.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot</span></tt>([navigator,&nbsp;axes_manager])</td>
<td>Plot the signal at the current coordinates.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_factors</span></tt>([comp_ids,&nbsp;calibrate,&nbsp;...])</td>
<td>Plot factors from blind source separation results.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_loadings</span></tt>([comp_ids,&nbsp;calibrate,&nbsp;...])</td>
<td>Plot loadings from ICA</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_results</span></tt>([factors_navigator,&nbsp;...])</td>
<td>Plot the blind source separation factors and loadings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_cumulative_explained_variance_ratio</span></tt>([n])</td>
<td>Plot the principal components explained variance up to the</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_factors</span></tt>([comp_ids,&nbsp;...])</td>
<td>Plot factors from a decomposition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_loadings</span></tt>([comp_ids,&nbsp;...])</td>
<td>Plot loadings from PCA.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_results</span></tt>([...])</td>
<td>Plot the decompostion factors and loadings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_explained_variance_ratio</span></tt>([n,&nbsp;log])</td>
<td>Plot the decomposition explained variance ratio vs index number.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum.power_law_extrapolation" title="hyperspy._signals.eels.EELSSpectrum.power_law_extrapolation"><tt class="xref py py-obj docutils literal"><span class="pre">power_law_extrapolation</span></tt></a>([window_size,&nbsp;...])</td>
<td>Extrapolate the spectrum to the right using a powerlaw</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">print_summary_statistics</span></tt>([formatter])</td>
<td>Prints the five-number summary statistics of the data, the mean and the standard deviation.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">rebin</span></tt>(new_shape)</td>
<td>Returns the object with the data rebinned.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">remove_background</span></tt>([signal_range,&nbsp;...])</td>
<td>Remove the background, either in place using a gui or returned as a new spectrum using the command line.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse_bss_component</span></tt>(component_number)</td>
<td>Reverse the independent component</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse_decomposition_component</span></tt>(component_number)</td>
<td>Reverse the decomposition component</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum.richardson_lucy_deconvolution" title="hyperspy._signals.eels.EELSSpectrum.richardson_lucy_deconvolution"><tt class="xref py py-obj docutils literal"><span class="pre">richardson_lucy_deconvolution</span></tt></a>(psf[,&nbsp;...])</td>
<td>1D Richardson-Lucy Poissonian deconvolution of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">rollaxis</span></tt>(axis,&nbsp;to_axis)</td>
<td>Roll the specified axis backwards, until it lies in a given position.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">save</span></tt>([filename,&nbsp;overwrite,&nbsp;extension])</td>
<td>Saves the signal in the specified format.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum.set_microscope_parameters" title="hyperspy._signals.eels.EELSSpectrum.set_microscope_parameters"><tt class="xref py py-obj docutils literal"><span class="pre">set_microscope_parameters</span></tt></a>([beam_energy,&nbsp;...])</td>
<td>Set the microscope parameters that are necessary to calculate the GOS.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_signal_origin</span></tt>(origin)</td>
<td>Set the origin of the signal and change the current class accordingly if pertinent.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_signal_type</span></tt>(signal_type)</td>
<td>Set the signal type and change the current class accordingly if pertinent.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">shift1D</span></tt>(shift_array[,&nbsp;interpolation_method,&nbsp;...])</td>
<td>Shift the data in place over the signal axis by the amount specified by an array.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_lowess</span></tt>([smoothing_parameter,&nbsp;...])</td>
<td>Lowess data smoothing in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_savitzky_golay</span></tt>([polynomial_order,&nbsp;...])</td>
<td>Apply a Savitzky-Golay filter to the data in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_tv</span></tt>([smoothing_parameter,&nbsp;...])</td>
<td>Total variation data smoothing in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">spikes_removal_tool</span></tt>([signal_mask,&nbsp;...])</td>
<td>Graphical interface to remove spikes from EELS spectra.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">split</span></tt>([axis,&nbsp;number_of_parts,&nbsp;step_sizes])</td>
<td>Splits the data into several signals.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">squeeze</span></tt>()</td>
<td>Remove single-dimensional entries from the shape of an array and the axes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">std</span></tt>(axis)</td>
<td>Returns a signal with the standard deviation of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">sum</span></tt>(axis)</td>
<td>Sum the data over the given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">swap_axes</span></tt>(axis1,&nbsp;axis2)</td>
<td>Swaps the axes.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_EDS</span></tt>([microscope])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_EELS</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_image</span></tt>()</td>
<td>Returns the spectrum as an image.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">undo_treatments</span></tt>()</td>
<td>Undo normalize_poissonian_noise</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold</span></tt>()</td>
<td>Modifies the shape of the data by unfolding the signal and</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_if_multidim</span></tt>()</td>
<td>Unfold the datacube if it is &gt;2D</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_navigation_space</span></tt>()</td>
<td>Modify the shape of the data to obtain a navigation space of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_signal_space</span></tt>()</td>
<td>Modify the shape of the data to obtain a signal space of</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">valuemax</span></tt>(axis)</td>
<td>Returns a signal with the value of the maximum along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">var</span></tt>(axis)</td>
<td>Returns a signal with the variances of the signal along an axis.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum.add_elements">
<tt class="descname">add_elements</tt><span class="sig-paren">(</span><em>elements</em>, <em>include_pre_edges=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum.add_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare the elemental composition of the sample.</p>
<p>The ionisation edges of the elements present in the current
energy range will be added automatically.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elements</strong> : tuple of strings</p>
<blockquote>
<div><p>The symbol of the elements. Note this input must always be
in the form of a tuple. Meaning: add_elements((&#8216;C&#8217;,)) will
work, while add_elements((&#8216;C&#8217;)) will NOT work.</p>
</div></blockquote>
<p><strong>include_pre_edges</strong> : bool</p>
<blockquote>
<div><p>If True, the ionization edges with an onset below the lower
energy limit of the SI will be incluided</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>ValueError</strong> :</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">signals</span><span class="o">.</span><span class="n">EELSSpectrum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1024</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_elements</span><span class="p">((</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="s">&#39;O&#39;</span><span class="p">))</span>
<span class="go">Adding C_K subshell</span>
<span class="go">Adding O_K subshell</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum.align_zero_loss_peak">
<tt class="descname">align_zero_loss_peak</tt><span class="sig-paren">(</span><em>calibrate=True</em>, <em>also_align=</em>, <span class="optional">[</span><span class="optional">]</span><em>print_stats=True</em>, <em>subpixel=True</em>, <em>mask=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum.align_zero_loss_peak" title="Permalink to this definition">¶</a></dt>
<dd><p>Align the zero-loss peak.</p>
<p>This function first aligns the spectra using the result of
<cite>estimate_zero_loss_peak_centre</cite> and afterward, if subpixel is True,
proceeds to align with subpixel accuracy using <cite>align1D</cite>. The offset
is automatically correct if <cite>calibrate</cite> is True.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>calibrate</strong> : bool</p>
<blockquote>
<div><p>If True, set the offset of the spectral axis so that the
zero-loss peak is at position zero.</p>
</div></blockquote>
<p><strong>also_align</strong> : list of signals</p>
<blockquote>
<div><p>A list containing other spectra of identical dimensions to
align using the shifts applied to the current spectrum.
If <cite>calibrate</cite> is True, the calibration is also applied to
the spectra in the list.</p>
</div></blockquote>
<p><strong>print_stats</strong> : bool</p>
<blockquote>
<div><p>If True, print summary statistics the ZLP maximum before
the aligment.</p>
</div></blockquote>
<p><strong>subpixel</strong> : bool</p>
<blockquote>
<div><p>If True, perform the alignment with subpixel accuracy
using cross-correlation.</p>
</div></blockquote>
<p><strong>mask</strong> : Signal of bool data type.</p>
<blockquote class="last">
<div><p>It must have signal_dimension = 0 and navigation_shape equal to the
current signal. Where mask is True the shift is not computed
and set to nan.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum.estimate_zero_loss_peak_centre" title="hyperspy._signals.eels.EELSSpectrum.estimate_zero_loss_peak_centre"><tt class="xref py py-obj docutils literal"><span class="pre">estimate_zero_loss_peak_centre</span></tt></a>, <tt class="xref py py-obj docutils literal"><span class="pre">align1D</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift1D.</span></tt></p>
</div>
<p class="rubric">Notes</p>
<p>Any extra keyword arguments are passed to <cite>align1D</cite>. For
more information read its docstring.</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum.estimate_elastic_scattering_intensity">
<tt class="descname">estimate_elastic_scattering_intensity</tt><span class="sig-paren">(</span><em>threshold</em>, <em>show_progressbar=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum.estimate_elastic_scattering_intensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Rough estimation of the elastic scattering intensity by
truncation of a EELS low-loss spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>threshold</strong> : {Signal, float, int}</p>
<blockquote>
<div><p>Truncation energy to estimate the intensity of the
elastic scattering. The
threshold can be provided as a signal of the same dimension
as the input spectrum navigation space containing the
threshold value in the energy units. Alternatively a constant
threshold can be specified in energy/index units by passing
float/int.</p>
</div></blockquote>
<p><strong>show_progressbar</strong> : None or bool</p>
<blockquote>
<div><p>If True, display a progress bar. If None the default is set in
<cite>preferences</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>I0: Signal</strong> :</p>
<blockquote class="last">
<div><p>The elastic scattering intensity.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum.estimate_elastic_scattering_threshold" title="hyperspy._signals.eels.EELSSpectrum.estimate_elastic_scattering_threshold"><tt class="xref py py-obj docutils literal"><span class="pre">estimate_elastic_scattering_threshold</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum.estimate_elastic_scattering_threshold">
<tt class="descname">estimate_elastic_scattering_threshold</tt><span class="sig-paren">(</span><em>window=10.0</em>, <em>tol=None</em>, <em>window_length=5</em>, <em>polynomial_order=3</em>, <em>start=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum.estimate_elastic_scattering_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the first inflexion point of the spectrum derivative
within a window.</p>
<p>This method assumes that the zero-loss peak is located at position zero
in all the spectra. Currently it looks for an inflexion point, that can
be a local maximum or minimum. Therefore, to estimate the elastic
scattering threshold <cite>start</cite> + <cite>window</cite> must be less than the first
maximum for all spectra (often the bulk plasmon maximum). If there is
more than one inflexion point in energy the window it selects the
smoother one what, often, but not always, is a good choice in this
case.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>window</strong> : {None, float}</p>
<blockquote>
<div><p>If None, the search for the local inflexion point is performed
using the full energy range. A positive float will restrict
the search to the (0,window] energy window, where window is given
in the axis units. If no inflexion point is found in this
spectral range the window value is returned instead.</p>
</div></blockquote>
<p><strong>tol</strong> : {None, float}</p>
<blockquote>
<div><p>The threshold tolerance for the derivative. If &#8220;auto&#8221; it is
automatically calculated as the minimum value that guarantees
finding an inflexion point in all the spectra in given energy
range.</p>
</div></blockquote>
<p><strong>window_length</strong> : int</p>
<blockquote>
<div><p>If non zero performs order three Savitzky-Golay smoothing
to the data to avoid falling in local minima caused by
the noise. It must be an odd interger.</p>
</div></blockquote>
<p><strong>polynomial_order</strong> : int</p>
<blockquote>
<div><p>Savitzky-Golay filter polynomial order.</p>
</div></blockquote>
<p><strong>start</strong> : float</p>
<blockquote>
<div><p>Position from the zero-loss peak centre from where to start
looking for the inflexion point.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>threshold</strong> : Signal</p>
<blockquote class="last">
<div><p>A Signal of the same dimension as the input spectrum
navigation space containing the estimated threshold. Where the
threshold couldn&#8217;t be estimated the value is set to nan.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum.estimate_elastic_scattering_intensity" title="hyperspy._signals.eels.EELSSpectrum.estimate_elastic_scattering_intensity"><tt class="xref py py-obj docutils literal"><span class="pre">estimate_elastic_scattering_intensity</span></tt></a>, <a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum.align_zero_loss_peak" title="hyperspy._signals.eels.EELSSpectrum.align_zero_loss_peak"><tt class="xref py py-obj docutils literal"><span class="pre">align_zero_loss_peak</span></tt></a>, <tt class="xref py py-obj docutils literal"><span class="pre">find_peaks1D_ohaver</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">fourier_ratio_deconvolution.</span></tt></p>
</div>
<p class="rubric">Notes</p>
<p>The main purpose of this method is to be used as input for
<cite>estimate_elastic_scattering_intensity</cite>. Indeed, for currently
achievable energy resolutions, there is not such a thing as a elastic
scattering threshold. Therefore, please be aware of the limitations of
this method when using it.</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum.estimate_thickness">
<tt class="descname">estimate_thickness</tt><span class="sig-paren">(</span><em>threshold</em>, <em>zlp=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum.estimate_thickness" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates the thickness (relative to the mean free path)
of a sample using the log-ratio method.</p>
<p>The current EELS spectrum must be a low-loss spectrum containing
the zero-loss peak. The hyperspectrum must be well calibrated
and aligned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>threshold</strong> : {Signal, float, int}</p>
<blockquote>
<div><p>Truncation energy to estimate the intensity of the
elastic scattering. The
threshold can be provided as a signal of the same dimension
as the input spectrum navigation space containing the
threshold value in the energy units. Alternatively a constant
threshold can be specified in energy/index units by passing
float/int.</p>
</div></blockquote>
<p><strong>zlp</strong> : {None, EELSSpectrum}</p>
<blockquote>
<div><p>If not None the zero-loss
peak intensity is calculated from the ZLP spectrum
supplied by integration using Simpson&#8217;s rule. If None estimates
the zero-loss peak intensity using
<cite>estimate_elastic_scattering_intensity</cite> by truncation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>s</strong> : Signal</p>
<blockquote class="last">
<div><p>The thickness relative to the MFP. It returns a Spectrum,
Image or a Signal, depending on the currenct spectrum navigation
dimensions.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For details see: Egerton, R. Electron Energy-Loss
Spectroscopy in the Electron Microscope. Springer-Verlag, 2011.</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum.estimate_zero_loss_peak_centre">
<tt class="descname">estimate_zero_loss_peak_centre</tt><span class="sig-paren">(</span><em>mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum.estimate_zero_loss_peak_centre" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the posision of the zero-loss peak.</p>
<p>This function provides just a coarse estimation of the position
of the zero-loss peak centre by computing the position of the maximum
of the spectra. For subpixel accuracy use <cite>estimate_shift1D</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mask</strong> : Signal of bool data type.</p>
<blockquote>
<div><p>It must have signal_dimension = 0 and navigation_shape equal to the
current signal. Where mask is True the shift is not computed
and set to nan.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>zlpc</strong> : Signal subclass</p>
<blockquote class="last">
<div><p>The estimated position of the maximum of the ZLP peak.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift1D</span></tt>, <a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum.align_zero_loss_peak" title="hyperspy._signals.eels.EELSSpectrum.align_zero_loss_peak"><tt class="xref py py-obj docutils literal"><span class="pre">align_zero_loss_peak</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<p>This function only works when the zero-loss peak is the most
intense feature in the spectrum. If it is not in most cases
the spectrum can be cropped to meet this criterium.
Alternatively use <cite>estimate_shift1D</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum.fourier_log_deconvolution">
<tt class="descname">fourier_log_deconvolution</tt><span class="sig-paren">(</span><em>zlp</em>, <em>add_zlp=False</em>, <em>crop=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum.fourier_log_deconvolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs fourier-log deconvolution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>zlp</strong> : EELSSpectrum</p>
<blockquote>
<div><p>The corresponding zero-loss peak.</p>
</div></blockquote>
<p><strong>add_zlp</strong> : bool</p>
<blockquote>
<div><p>If True, adds the ZLP to the deconvolved spectrum</p>
</div></blockquote>
<p><strong>crop</strong> : bool</p>
<blockquote>
<div><p>If True crop the spectrum to leave out the channels that
have been modified to decay smoothly to zero at the sides
of the spectrum.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>An EELSSpectrum containing the current data deconvolved.</strong> :</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For details see: Egerton, R. Electron Energy-Loss
Spectroscopy in the Electron Microscope. Springer-Verlag, 2011.</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum.fourier_ratio_deconvolution">
<tt class="descname">fourier_ratio_deconvolution</tt><span class="sig-paren">(</span><em>ll</em>, <em>fwhm=None</em>, <em>threshold=None</em>, <em>extrapolate_lowloss=True</em>, <em>extrapolate_coreloss=True</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum.fourier_ratio_deconvolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs Fourier-ratio deconvolution.</p>
<dl class="docutils">
<dt>The core-loss should have the background removed. To reduce</dt>
<dd>the noise amplication the result is convolved with a</dd>
</dl>
<p>Gaussian function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ll: EELSSpectrum</strong> :</p>
<blockquote>
<div><p>The corresponding low-loss (ll) EELSSpectrum.</p>
</div></blockquote>
<p><strong>fwhm</strong> : float or None</p>
<blockquote>
<div><p>Full-width half-maximum of the Gaussian function by which
the result of the deconvolution is convolved. It can be
used to select the final SNR and spectral resolution. If
None, the FWHM of the zero-loss peak of the low-loss is
estimated and used.</p>
</div></blockquote>
<p><strong>threshold</strong> : {None, float}</p>
<blockquote>
<div><p>Truncation energy to estimate the intensity of the
elastic scattering. If None the threshold is taken as the</p>
<blockquote>
<div><p>first minimum after the ZLP centre.</p>
</div></blockquote>
</div></blockquote>
<p><strong>extrapolate_lowloss, extrapolate_coreloss</strong> : bool</p>
<blockquote class="last">
<div><p>If True the signals are extrapolated using a power law,</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For details see: Egerton, R. Electron Energy-Loss
Spectroscopy in the Electron Microscope. Springer-Verlag, 2011.</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum.generate_subshells">
<tt class="descname">generate_subshells</tt><span class="sig-paren">(</span><em>include_pre_edges=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum.generate_subshells" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the subshells for the current energy range for the
elements present in self.elements</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>include_pre_edges</strong> : bool</p>
<blockquote class="last">
<div><p>If True, the ionization edges with an onset below the lower
energy limit of the SI will be incluided</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum.kramers_kronig_analysis">
<tt class="descname">kramers_kronig_analysis</tt><span class="sig-paren">(</span><em>zlp=None</em>, <em>iterations=1</em>, <em>n=None</em>, <em>t=None</em>, <em>delta=0.5</em>, <em>full_output=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum.kramers_kronig_analysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the complex
dielectric function from a single scattering distribution (SSD) using
the Kramers-Kronig relations.</p>
<p>It uses the FFT method as in <a class="reference internal" href="../user_guide/bibliography.html#egerton2011" id="id2">[Egerton2011]</a>.  The SSD is an
EELSSpectrum instance containing SSD low-loss EELS with no zero-loss
peak. The internal loop is devised to approximately subtract the
surface plasmon contribution supposing an unoxidized planar surface and
neglecting coupling between the surfaces. This method does not account
for retardation effects, instrumental broading and surface plasmon
excitation in particles.</p>
<p>Note that either refractive index or thickness are required.
If both are None or if both are provided an exception is raised.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>zlp: {None, number, Signal}</strong> :</p>
<blockquote>
<div><p>ZLP intensity. It is optional (can be None) if <cite>t</cite> is None and <cite>n</cite>
is not None and the thickness estimation is not required. If <cite>t</cite>
is not None, the ZLP is required to perform the normalization and
if <cite>t</cite> is not None, the ZLP is required to calculate the thickness.
If the ZLP is the same for all spectra, the integral of the ZLP
can be provided as a number. Otherwise, if the ZLP intensity is not
the same for all spectra, it can be provided as i) a Signal
of the same dimensions as the current signal containing the ZLP
spectra for each location ii) a Signal of signal dimension 0
and navigation_dimension equal to the current signal containing the
integrated ZLP intensity.</p>
</div></blockquote>
<p><strong>iterations: int</strong> :</p>
<blockquote>
<div><p>Number of the iterations for the internal loop to remove the
surface plasmon contribution. If 1 the surface plasmon contribution
is not estimated and subtracted (the default is 1).</p>
</div></blockquote>
<p><strong>n: {None, float}</strong> :</p>
<blockquote>
<div><p>The medium refractive index. Used for normalization of the
SSD to obtain the energy loss function. If given the thickness
is estimated and returned. It is only required when <cite>t</cite> is None.</p>
</div></blockquote>
<p><strong>t: {None, number, Signal}</strong> :</p>
<blockquote>
<div><p>The sample thickness in nm. Used for normalization of the
SSD to obtain the energy loss function. It is only required when
<cite>n</cite> is None. If the thickness is the same for all spectra it can be
given by a number. Otherwise, it can be provided as a Signal with
signal dimension 0 and navigation_dimension equal to the current
signal.</p>
</div></blockquote>
<p><strong>delta</strong> : float</p>
<blockquote>
<div><p>A small number (0.1-0.5 eV) added to the energy axis in
specific steps of the calculation the surface loss correction to
improve stability.</p>
</div></blockquote>
<p><strong>full_output</strong> : bool</p>
<blockquote>
<div><p>If True, return a dictionary that contains the estimated
thickness if <cite>t</cite> is None and the estimated surface plasmon
excitation and the spectrum corrected from surface plasmon
excitations if <cite>iterations</cite> &gt; 1.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>eps: DielectricFunction instance</strong> :</p>
<blockquote>
<div><dl class="docutils">
<dt>The complex dielectric function results,</dt>
<dd><p class="first last">$epsilon = epsilon_1 + i*epsilon_2$,</p>
</dd>
</dl>
<p>contained in an DielectricFunction instance.</p>
</div></blockquote>
<p><strong>output: Dictionary (optional)</strong> :</p>
<blockquote>
<div><p>A dictionary of optional outputs with the following keys:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">thickness</span></tt></dt>
<dd><p class="first last">The estimated  thickness in nm calculated by normalization of
the SSD (only when <cite>t</cite> is None)</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">surface</span> <span class="pre">plasmon</span> <span class="pre">estimation</span></tt></dt>
<dd><p class="first last">The estimated surface plasmon excitation (only if
<cite>iterations</cite> &gt; 1.)</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValuerError</strong> :</p>
<blockquote>
<div><p>If both <cite>n</cite> and <cite>t</cite> are undefined (None).</p>
</div></blockquote>
<p><strong>AttribureError</strong> :</p>
<blockquote class="last">
<div><p>If the beam_energy or the collection angle are not defined in
metadata.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This method is based in Egerton&#8217;s Matlab code <a class="reference internal" href="../user_guide/bibliography.html#egerton2011" id="id3">[Egerton2011]</a> with some
minor differences:</p>
<ul class="simple">
<li>The integrals are performed using the simpsom rule instead of using
a summation.</li>
<li>The wrap-around problem when computing the ffts is workarounded by
padding the signal instead of substracting the reflected tail.</li>
</ul>
<table class="docutils citation" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Egerton2011]</td><td>Ray Egerton, &#8220;Electron Energy-Loss
Spectroscopy in the Electron Microscope&#8221;, Springer-Verlag, 2011.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum.power_law_extrapolation">
<tt class="descname">power_law_extrapolation</tt><span class="sig-paren">(</span><em>window_size=20</em>, <em>extrapolation_size=1024</em>, <em>add_noise=False</em>, <em>fix_neg_r=False</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum.power_law_extrapolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Extrapolate the spectrum to the right using a powerlaw</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>window_size</strong> : int</p>
<blockquote>
<div><p>The number of channels from the right side of the
spectrum that are used to estimate the power law
parameters.</p>
</div></blockquote>
<p><strong>extrapolation_size</strong> : int</p>
<blockquote>
<div><p>Size of the extrapolation in number of channels</p>
</div></blockquote>
<p><strong>add_noise</strong> : bool</p>
<blockquote>
<div><p>If True, add poissonian noise to the extrapolated spectrum.</p>
</div></blockquote>
<p><strong>fix_neg_r</strong> : bool</p>
<blockquote>
<div><p>If True, the negative values for the &#8220;components.PowerLaw&#8221;
parameter r will be flagged and the extrapolation will be
done with a constant zero-value.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>A new spectrum, with the extrapolation.</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum.richardson_lucy_deconvolution">
<tt class="descname">richardson_lucy_deconvolution</tt><span class="sig-paren">(</span><em>psf</em>, <em>iterations=15</em>, <em>mask=None</em>, <em>show_progressbar=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum.richardson_lucy_deconvolution" title="Permalink to this definition">¶</a></dt>
<dd><p>1D Richardson-Lucy Poissonian deconvolution of
the spectrum by the given kernel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>iterations: int</strong> :</p>
<blockquote>
<div><p>Number of iterations of the deconvolution. Note that
increasing the value will increase the noise amplification.</p>
</div></blockquote>
<p><strong>psf: EELSSpectrum</strong> :</p>
<blockquote>
<div><p>It must have the same signal dimension as the current
spectrum and a spatial dimension of 0 or the same as the
current spectrum.</p>
</div></blockquote>
<p><strong>show_progressbar</strong> : None or bool</p>
<blockquote>
<div><p>If True, display a progress bar. If None the default is set in
<cite>preferences</cite>.</p>
</div></blockquote>
<p><strong>Notes:</strong> :</p>
<p><strong>&#8212;&#8211;</strong> :</p>
<p><strong>For details on the algorithm see Gloter, A., A. Douiri,</strong> :</p>
<p><strong>M. Tence, and C. Colliex. “Improving Energy Resolution of</strong> :</p>
<p><strong>EELS Spectra: An Alternative to the Monochromator Solution.”</strong> :</p>
<p class="last"><strong>Ultramicroscopy 96, no. 3–4 (September 2003): 385–400.</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.eels.EELSSpectrum.set_microscope_parameters">
<tt class="descname">set_microscope_parameters</tt><span class="sig-paren">(</span><em>beam_energy=None</em>, <em>convergence_angle=None</em>, <em>collection_angle=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels.EELSSpectrum.set_microscope_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the microscope parameters that are necessary to calculate
the GOS.</p>
<p>If not all of them are defined, raises in interactive mode
raises an UI item to fill the values</p>
<dl class="docutils">
<dt>beam_energy: float</dt>
<dd>The energy of the electron beam in keV</dd>
<dt>convengence_angle <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>In mrad.</dd>
<dt>collection_angle <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>In mrad.</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.eels_spectrum_simulation">
<span id="hyperspy-signals-eels-spectrum-simulation-module"></span><h2>hyperspy._signals.eels_spectrum_simulation module<a class="headerlink" href="#module-hyperspy._signals.eels_spectrum_simulation" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.eels_spectrum_simulation.EELSSpectrumSimulation">
<em class="property">class </em><tt class="descclassname">hyperspy._signals.eels_spectrum_simulation.</tt><tt class="descname">EELSSpectrumSimulation</tt><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.eels_spectrum_simulation.EELSSpectrumSimulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.spectrum_simulation.SpectrumSimulation" title="hyperspy._signals.spectrum_simulation.SpectrumSimulation"><tt class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.spectrum_simulation.SpectrumSimulation</span></tt></a>, <a class="reference internal" href="#hyperspy._signals.eels.EELSSpectrum" title="hyperspy._signals.eels.EELSSpectrum"><tt class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.eels.EELSSpectrum</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">add_elements</span></tt>(elements[,&nbsp;include_pre_edges])</td>
<td>Declare the elemental composition of the sample.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">add_gaussian_noise</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Add Gaussian noise to the data</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">add_poissonian_noise</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Add Poissonian noise to the data</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">align1D</span></tt>([start,&nbsp;end,&nbsp;reference_indices,&nbsp;...])</td>
<td>Estimate the shifts in the signal axis using cross-correlation and use the estimation to align the data in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">align2D</span></tt>([crop,&nbsp;fill_value,&nbsp;shifts,&nbsp;roi,&nbsp;...])</td>
<td>Align the images in place using user provided shifts or by estimating the shifts.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">align_zero_loss_peak</span></tt>([calibrate,&nbsp;...])</td>
<td>Align the zero-loss peak.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">anscombe</span></tt>()</td>
<td>Anscombe transform.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">anscombe_inverse</span></tt>([method])</td>
<td>Inverse anscombe transform.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_image</span></tt>(image_axes)</td>
<td>Convert signal to image.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_spectrum</span></tt>(spectral_axis)</td>
<td>Return the Signal as a spectrum.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">blind_source_separation</span></tt>([...])</td>
<td>Blind source separation (BSS) on the result on the decomposition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">calibrate</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Calibrate the spectral dimension using a gui.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_dtype</span></tt>(dtype)</td>
<td>Change the data type.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop</span></tt>(axis[,&nbsp;start,&nbsp;end])</td>
<td>Crops the data in a given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop_image</span></tt>([top,&nbsp;bottom,&nbsp;left,&nbsp;right])</td>
<td>Crops an image in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop_spectrum</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Crop in place the spectral dimension.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">decomposition</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Decomposition with a choice of algorithms</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">deepcopy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">diff</span></tt>(axis[,&nbsp;order])</td>
<td>Returns a signal with the n-th order discrete difference along given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_elastic_scattering_intensity</span></tt>(threshold)</td>
<td>Rough estimation of the elastic scattering intensity by truncation of a EELS low-loss spectrum.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_elastic_scattering_threshold</span></tt>([...])</td>
<td>Calculate the first inflexion point of the spectrum derivative within a window.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_peak_width</span></tt>([factor,&nbsp;window,&nbsp;...])</td>
<td>Estimate the width of the highest intensity of peak of the spectra at a given fraction of its maximum.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_poissonian_noise_variance</span></tt>([...])</td>
<td>Estimate the poissonian noise variance of the signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift1D</span></tt>([start,&nbsp;end,&nbsp;...])</td>
<td>Estimate the shifts in the current signal axis using  cross-correlation.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift2D</span></tt>([reference,&nbsp;...])</td>
<td>Estimate the shifts in a image using phase correlation</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_thickness</span></tt>(threshold[,&nbsp;zlp])</td>
<td>Estimates the thickness (relative to the mean free path) of a sample using the log-ratio method.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_zero_loss_peak_centre</span></tt>([mask])</td>
<td>Estimate the posision of the zero-loss peak.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">export_bss_results</span></tt>([comp_ids,&nbsp;folder,&nbsp;...])</td>
<td>Export results from ICA to any of the supported formats.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">export_decomposition_results</span></tt>([comp_ids,&nbsp;...])</td>
<td>Export results from a decomposition to any of the supported formats.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">filter_butterworth</span></tt>([cutoff_frequency_ratio,&nbsp;...])</td>
<td>Butterworth filter in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">find_peaks1D_ohaver</span></tt>([xdim,&nbsp;slope_thresh,&nbsp;...])</td>
<td>Find peaks along a 1D line (peaks in spectrum/spectra).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">fold</span></tt>(*args,&nbsp;**kwargs)</td>
<td>If the signal was previously unfolded, folds it back</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">fourier_log_deconvolution</span></tt>(zlp[,&nbsp;add_zlp,&nbsp;crop])</td>
<td>Performs fourier-log deconvolution.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">fourier_ratio_deconvolution</span></tt>(ll[,&nbsp;fwhm,&nbsp;...])</td>
<td>Performs Fourier-ratio deconvolution.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">gaussian_filter</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Applies a Gaussian filter in the spectral dimension in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">generate_subshells</span></tt>([include_pre_edges])</td>
<td>Calculate the subshells for the current energy range for the</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_factors</span></tt>()</td>
<td>Return the blind source separtion factors as a Signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_loadings</span></tt>()</td>
<td>Return the blind source separtion loadings as a Signal.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_model</span></tt>([components])</td>
<td>Return the spectrum generated with the selected number of</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_current_signal</span></tt>([auto_title,&nbsp;auto_filename])</td>
<td>Returns the data at the current coordinates as a Signal subclass.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_factors</span></tt>()</td>
<td>Return the decomposition factors as a Signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_loadings</span></tt>()</td>
<td>Return the decomposition loadings as a Signal.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_model</span></tt>([components])</td>
<td>Return the spectrum generated with the selected number of principal</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_dimensions_from_data</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Get the dimension parameters from the data_cube.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_explained_variance_ratio</span></tt>()</td>
<td>Return the explained variation ratio of the PCA components as a Spectrum.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_histogram</span></tt>(img[,&nbsp;bins,&nbsp;range_bins])</td>
<td>Return a histogram of the signal data.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">hanning_taper</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Apply a hanning taper to the data in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">indexmax</span></tt>(axis)</td>
<td>Returns a signal with the index of the maximum along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate1D</span></tt>(axis)</td>
<td>Integrate the signal over the given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate_in_range</span></tt>([signal_range])</td>
<td>Sums the spectrum over an energy range, giving the integrated area.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate_simpson</span></tt>(axis)</td>
<td>Returns a signal with the result of calculating the integral of the signal along an axis using Simpson&#8217;s rule.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">interpolate_in_between</span></tt>(start,&nbsp;end[,&nbsp;delta,&nbsp;...])</td>
<td>Replace the data in a given range by interpolation.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">kramers_kronig_analysis</span></tt>([zlp,&nbsp;iterations,&nbsp;...])</td>
<td>Calculate the complex dielectric function from a single scattering distribution (SSD) using the Kramers-Kronig relations.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">map</span></tt>(function[,&nbsp;show_progressbar])</td>
<td>Apply a function to the signal data at all the coordinates.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">max</span></tt>(axis[,&nbsp;return_signal])</td>
<td>Returns a signal with the maximum of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">mean</span></tt>(axis)</td>
<td>Returns a signal with the average of the signal along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">min</span></tt>(axis)</td>
<td>Returns a signal with the minimum of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">next</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">normalize_factors</span></tt>([which,&nbsp;by,&nbsp;sort])</td>
<td>Normalises the factors and modifies the loadings</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">normalize_poissonian_noise</span></tt>([...])</td>
<td>Scales the SI following Surf.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot</span></tt>([navigator,&nbsp;axes_manager])</td>
<td>Plot the signal at the current coordinates.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_factors</span></tt>([comp_ids,&nbsp;calibrate,&nbsp;...])</td>
<td>Plot factors from blind source separation results.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_loadings</span></tt>([comp_ids,&nbsp;calibrate,&nbsp;...])</td>
<td>Plot loadings from ICA</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_results</span></tt>([factors_navigator,&nbsp;...])</td>
<td>Plot the blind source separation factors and loadings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_cumulative_explained_variance_ratio</span></tt>([n])</td>
<td>Plot the principal components explained variance up to the</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_factors</span></tt>([comp_ids,&nbsp;...])</td>
<td>Plot factors from a decomposition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_loadings</span></tt>([comp_ids,&nbsp;...])</td>
<td>Plot loadings from PCA.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_results</span></tt>([...])</td>
<td>Plot the decompostion factors and loadings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_explained_variance_ratio</span></tt>([n,&nbsp;log])</td>
<td>Plot the decomposition explained variance ratio vs index number.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">power_law_extrapolation</span></tt>([window_size,&nbsp;...])</td>
<td>Extrapolate the spectrum to the right using a powerlaw</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">print_summary_statistics</span></tt>([formatter])</td>
<td>Prints the five-number summary statistics of the data, the mean and the standard deviation.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">rebin</span></tt>(new_shape)</td>
<td>Returns the object with the data rebinned.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">remove_background</span></tt>([signal_range,&nbsp;...])</td>
<td>Remove the background, either in place using a gui or returned as a new spectrum using the command line.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse_bss_component</span></tt>(component_number)</td>
<td>Reverse the independent component</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse_decomposition_component</span></tt>(component_number)</td>
<td>Reverse the decomposition component</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">richardson_lucy_deconvolution</span></tt>(psf[,&nbsp;...])</td>
<td>1D Richardson-Lucy Poissonian deconvolution of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">rollaxis</span></tt>(axis,&nbsp;to_axis)</td>
<td>Roll the specified axis backwards, until it lies in a given position.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">save</span></tt>([filename,&nbsp;overwrite,&nbsp;extension])</td>
<td>Saves the signal in the specified format.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_microscope_parameters</span></tt>([beam_energy,&nbsp;...])</td>
<td>Set the microscope parameters that are necessary to calculate the GOS.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_signal_origin</span></tt>(origin)</td>
<td>Set the origin of the signal and change the current class accordingly if pertinent.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_signal_type</span></tt>(signal_type)</td>
<td>Set the signal type and change the current class accordingly if pertinent.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">shift1D</span></tt>(shift_array[,&nbsp;interpolation_method,&nbsp;...])</td>
<td>Shift the data in place over the signal axis by the amount specified by an array.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_lowess</span></tt>([smoothing_parameter,&nbsp;...])</td>
<td>Lowess data smoothing in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_savitzky_golay</span></tt>([polynomial_order,&nbsp;...])</td>
<td>Apply a Savitzky-Golay filter to the data in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_tv</span></tt>([smoothing_parameter,&nbsp;...])</td>
<td>Total variation data smoothing in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">spikes_removal_tool</span></tt>([signal_mask,&nbsp;...])</td>
<td>Graphical interface to remove spikes from EELS spectra.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">split</span></tt>([axis,&nbsp;number_of_parts,&nbsp;step_sizes])</td>
<td>Splits the data into several signals.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">squeeze</span></tt>()</td>
<td>Remove single-dimensional entries from the shape of an array and the axes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">std</span></tt>(axis)</td>
<td>Returns a signal with the standard deviation of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">sum</span></tt>(axis)</td>
<td>Sum the data over the given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">swap_axes</span></tt>(axis1,&nbsp;axis2)</td>
<td>Swaps the axes.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_EDS</span></tt>([microscope])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_EELS</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_image</span></tt>()</td>
<td>Returns the spectrum as an image.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">undo_treatments</span></tt>()</td>
<td>Undo normalize_poissonian_noise</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold</span></tt>()</td>
<td>Modifies the shape of the data by unfolding the signal and</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_if_multidim</span></tt>()</td>
<td>Unfold the datacube if it is &gt;2D</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_navigation_space</span></tt>()</td>
<td>Modify the shape of the data to obtain a navigation space of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_signal_space</span></tt>()</td>
<td>Modify the shape of the data to obtain a signal space of</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">valuemax</span></tt>(axis)</td>
<td>Returns a signal with the value of the maximum along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">var</span></tt>(axis)</td>
<td>Returns a signal with the variances of the signal along an axis.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.image">
<span id="hyperspy-signals-image-module"></span><h2>hyperspy._signals.image module<a class="headerlink" href="#module-hyperspy._signals.image" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.image.Image">
<em class="property">class </em><tt class="descclassname">hyperspy._signals.image.</tt><tt class="descname">Image</tt><span class="sig-paren">(</span><em>*args</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.image.Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="hyperspy.html#hyperspy.signal.Signal" title="hyperspy.signal.Signal"><tt class="xref py py-class docutils literal"><span class="pre">hyperspy.signal.Signal</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">align1D</span></tt>([start,&nbsp;end,&nbsp;reference_indices,&nbsp;...])</td>
<td>Estimate the shifts in the signal axis using cross-correlation and use the estimation to align the data in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">align2D</span></tt>([crop,&nbsp;fill_value,&nbsp;shifts,&nbsp;roi,&nbsp;...])</td>
<td>Align the images in place using user provided shifts or by estimating the shifts.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">anscombe</span></tt>()</td>
<td>Anscombe transform.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">anscombe_inverse</span></tt>([method])</td>
<td>Inverse anscombe transform.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_image</span></tt>(image_axes)</td>
<td>Convert signal to image.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_spectrum</span></tt>(spectral_axis)</td>
<td>Return the Signal as a spectrum.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">blind_source_separation</span></tt>([...])</td>
<td>Blind source separation (BSS) on the result on the decomposition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">calibrate</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Calibrate the spectral dimension using a gui.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_dtype</span></tt>(dtype)</td>
<td>Change the data type.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop</span></tt>(axis[,&nbsp;start,&nbsp;end])</td>
<td>Crops the data in a given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop_image</span></tt>([top,&nbsp;bottom,&nbsp;left,&nbsp;right])</td>
<td>Crops an image in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop_spectrum</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Crop in place the spectral dimension.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">decomposition</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Decomposition with a choice of algorithms</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">deepcopy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">diff</span></tt>(axis[,&nbsp;order])</td>
<td>Returns a signal with the n-th order discrete difference along given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_peak_width</span></tt>([factor,&nbsp;window,&nbsp;...])</td>
<td>Estimate the width of the highest intensity of peak of the spectra at a given fraction of its maximum.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_poissonian_noise_variance</span></tt>([...])</td>
<td>Estimate the poissonian noise variance of the signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift1D</span></tt>([start,&nbsp;end,&nbsp;...])</td>
<td>Estimate the shifts in the current signal axis using  cross-correlation.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift2D</span></tt>([reference,&nbsp;...])</td>
<td>Estimate the shifts in a image using phase correlation</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">export_bss_results</span></tt>([comp_ids,&nbsp;folder,&nbsp;...])</td>
<td>Export results from ICA to any of the supported formats.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">export_decomposition_results</span></tt>([comp_ids,&nbsp;...])</td>
<td>Export results from a decomposition to any of the supported formats.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">filter_butterworth</span></tt>([cutoff_frequency_ratio,&nbsp;...])</td>
<td>Butterworth filter in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">find_peaks1D_ohaver</span></tt>([xdim,&nbsp;slope_thresh,&nbsp;...])</td>
<td>Find peaks along a 1D line (peaks in spectrum/spectra).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">fold</span></tt>(*args,&nbsp;**kwargs)</td>
<td>If the signal was previously unfolded, folds it back</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">gaussian_filter</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Applies a Gaussian filter in the spectral dimension in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_factors</span></tt>()</td>
<td>Return the blind source separtion factors as a Signal.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_loadings</span></tt>()</td>
<td>Return the blind source separtion loadings as a Signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_model</span></tt>([components])</td>
<td>Return the spectrum generated with the selected number of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_current_signal</span></tt>([auto_title,&nbsp;auto_filename])</td>
<td>Returns the data at the current coordinates as a Signal subclass.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_factors</span></tt>()</td>
<td>Return the decomposition factors as a Signal.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_loadings</span></tt>()</td>
<td>Return the decomposition loadings as a Signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_model</span></tt>([components])</td>
<td>Return the spectrum generated with the selected number of principal</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_dimensions_from_data</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Get the dimension parameters from the data_cube.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_explained_variance_ratio</span></tt>()</td>
<td>Return the explained variation ratio of the PCA components as a Spectrum.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_histogram</span></tt>(img[,&nbsp;bins,&nbsp;range_bins])</td>
<td>Return a histogram of the signal data.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">hanning_taper</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Apply a hanning taper to the data in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">indexmax</span></tt>(axis)</td>
<td>Returns a signal with the index of the maximum along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate1D</span></tt>(axis)</td>
<td>Integrate the signal over the given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate_in_range</span></tt>([signal_range])</td>
<td>Sums the spectrum over an energy range, giving the integrated area.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate_simpson</span></tt>(axis)</td>
<td>Returns a signal with the result of calculating the integral of the signal along an axis using Simpson&#8217;s rule.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">interpolate_in_between</span></tt>(start,&nbsp;end[,&nbsp;delta,&nbsp;...])</td>
<td>Replace the data in a given range by interpolation.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">map</span></tt>(function[,&nbsp;show_progressbar])</td>
<td>Apply a function to the signal data at all the coordinates.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">max</span></tt>(axis[,&nbsp;return_signal])</td>
<td>Returns a signal with the maximum of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">mean</span></tt>(axis)</td>
<td>Returns a signal with the average of the signal along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">min</span></tt>(axis)</td>
<td>Returns a signal with the minimum of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">next</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">normalize_factors</span></tt>([which,&nbsp;by,&nbsp;sort])</td>
<td>Normalises the factors and modifies the loadings</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">normalize_poissonian_noise</span></tt>([...])</td>
<td>Scales the SI following Surf.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot</span></tt>([navigator,&nbsp;axes_manager])</td>
<td>Plot the signal at the current coordinates.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_factors</span></tt>([comp_ids,&nbsp;calibrate,&nbsp;...])</td>
<td>Plot factors from blind source separation results.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_loadings</span></tt>([comp_ids,&nbsp;calibrate,&nbsp;...])</td>
<td>Plot loadings from ICA</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_results</span></tt>([factors_navigator,&nbsp;...])</td>
<td>Plot the blind source separation factors and loadings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_cumulative_explained_variance_ratio</span></tt>([n])</td>
<td>Plot the principal components explained variance up to the</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_factors</span></tt>([comp_ids,&nbsp;...])</td>
<td>Plot factors from a decomposition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_loadings</span></tt>([comp_ids,&nbsp;...])</td>
<td>Plot loadings from PCA.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_results</span></tt>([...])</td>
<td>Plot the decompostion factors and loadings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_explained_variance_ratio</span></tt>([n,&nbsp;log])</td>
<td>Plot the decomposition explained variance ratio vs index number.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">print_summary_statistics</span></tt>([formatter])</td>
<td>Prints the five-number summary statistics of the data, the mean and the standard deviation.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">rebin</span></tt>(new_shape)</td>
<td>Returns the object with the data rebinned.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">remove_background</span></tt>([signal_range,&nbsp;...])</td>
<td>Remove the background, either in place using a gui or returned as a new spectrum using the command line.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse_bss_component</span></tt>(component_number)</td>
<td>Reverse the independent component</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse_decomposition_component</span></tt>(component_number)</td>
<td>Reverse the decomposition component</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">rollaxis</span></tt>(axis,&nbsp;to_axis)</td>
<td>Roll the specified axis backwards, until it lies in a given position.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">save</span></tt>([filename,&nbsp;overwrite,&nbsp;extension])</td>
<td>Saves the signal in the specified format.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_signal_origin</span></tt>(origin)</td>
<td>Set the origin of the signal and change the current class accordingly if pertinent.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_signal_type</span></tt>(signal_type)</td>
<td>Set the signal type and change the current class accordingly if pertinent.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">shift1D</span></tt>(shift_array[,&nbsp;interpolation_method,&nbsp;...])</td>
<td>Shift the data in place over the signal axis by the amount specified by an array.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_lowess</span></tt>([smoothing_parameter,&nbsp;...])</td>
<td>Lowess data smoothing in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_savitzky_golay</span></tt>([polynomial_order,&nbsp;...])</td>
<td>Apply a Savitzky-Golay filter to the data in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_tv</span></tt>([smoothing_parameter,&nbsp;...])</td>
<td>Total variation data smoothing in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">split</span></tt>([axis,&nbsp;number_of_parts,&nbsp;step_sizes])</td>
<td>Splits the data into several signals.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">squeeze</span></tt>()</td>
<td>Remove single-dimensional entries from the shape of an array and the axes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">std</span></tt>(axis)</td>
<td>Returns a signal with the standard deviation of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">sum</span></tt>(axis)</td>
<td>Sum the data over the given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">swap_axes</span></tt>(axis1,&nbsp;axis2)</td>
<td>Swaps the axes.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hyperspy._signals.image.Image.to_spectrum" title="hyperspy._signals.image.Image.to_spectrum"><tt class="xref py py-obj docutils literal"><span class="pre">to_spectrum</span></tt></a>()</td>
<td>Returns the image as a spectrum.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">undo_treatments</span></tt>()</td>
<td>Undo normalize_poissonian_noise</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold</span></tt>()</td>
<td>Modifies the shape of the data by unfolding the signal and</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_if_multidim</span></tt>()</td>
<td>Unfold the datacube if it is &gt;2D</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_navigation_space</span></tt>()</td>
<td>Modify the shape of the data to obtain a navigation space of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_signal_space</span></tt>()</td>
<td>Modify the shape of the data to obtain a signal space of</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">valuemax</span></tt>(axis)</td>
<td>Returns a signal with the value of the maximum along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">var</span></tt>(axis)</td>
<td>Returns a signal with the variances of the signal along an axis.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="hyperspy._signals.image.Image.to_spectrum">
<tt class="descname">to_spectrum</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.image.Image.to_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the image as a spectrum.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><tt class="xref py py-obj docutils literal"><span class="pre">as_spectrum</span></tt></dt>
<dd>a method for the same purpose with more options.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">signals.Image.to_spectrum</span></tt></dt>
<dd>performs the inverse operation on images.</dd>
</dl>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.image_simulation">
<span id="hyperspy-signals-image-simulation-module"></span><h2>hyperspy._signals.image_simulation module<a class="headerlink" href="#module-hyperspy._signals.image_simulation" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.image_simulation.ImageSimulation">
<em class="property">class </em><tt class="descclassname">hyperspy._signals.image_simulation.</tt><tt class="descname">ImageSimulation</tt><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.image_simulation.ImageSimulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.simulation.Simulation" title="hyperspy._signals.simulation.Simulation"><tt class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.simulation.Simulation</span></tt></a>, <a class="reference internal" href="#hyperspy._signals.image.Image" title="hyperspy._signals.image.Image"><tt class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.image.Image</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">add_gaussian_noise</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Add Gaussian noise to the data</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">add_poissonian_noise</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Add Poissonian noise to the data</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">align1D</span></tt>([start,&nbsp;end,&nbsp;reference_indices,&nbsp;...])</td>
<td>Estimate the shifts in the signal axis using cross-correlation and use the estimation to align the data in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">align2D</span></tt>([crop,&nbsp;fill_value,&nbsp;shifts,&nbsp;roi,&nbsp;...])</td>
<td>Align the images in place using user provided shifts or by estimating the shifts.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">anscombe</span></tt>()</td>
<td>Anscombe transform.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">anscombe_inverse</span></tt>([method])</td>
<td>Inverse anscombe transform.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_image</span></tt>(image_axes)</td>
<td>Convert signal to image.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_spectrum</span></tt>(spectral_axis)</td>
<td>Return the Signal as a spectrum.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">blind_source_separation</span></tt>([...])</td>
<td>Blind source separation (BSS) on the result on the decomposition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">calibrate</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Calibrate the spectral dimension using a gui.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_dtype</span></tt>(dtype)</td>
<td>Change the data type.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop</span></tt>(axis[,&nbsp;start,&nbsp;end])</td>
<td>Crops the data in a given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop_image</span></tt>([top,&nbsp;bottom,&nbsp;left,&nbsp;right])</td>
<td>Crops an image in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop_spectrum</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Crop in place the spectral dimension.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">decomposition</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Decomposition with a choice of algorithms</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">deepcopy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">diff</span></tt>(axis[,&nbsp;order])</td>
<td>Returns a signal with the n-th order discrete difference along given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_peak_width</span></tt>([factor,&nbsp;window,&nbsp;...])</td>
<td>Estimate the width of the highest intensity of peak of the spectra at a given fraction of its maximum.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_poissonian_noise_variance</span></tt>([...])</td>
<td>Estimate the poissonian noise variance of the signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift1D</span></tt>([start,&nbsp;end,&nbsp;...])</td>
<td>Estimate the shifts in the current signal axis using  cross-correlation.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift2D</span></tt>([reference,&nbsp;...])</td>
<td>Estimate the shifts in a image using phase correlation</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">export_bss_results</span></tt>([comp_ids,&nbsp;folder,&nbsp;...])</td>
<td>Export results from ICA to any of the supported formats.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">export_decomposition_results</span></tt>([comp_ids,&nbsp;...])</td>
<td>Export results from a decomposition to any of the supported formats.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">filter_butterworth</span></tt>([cutoff_frequency_ratio,&nbsp;...])</td>
<td>Butterworth filter in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">find_peaks1D_ohaver</span></tt>([xdim,&nbsp;slope_thresh,&nbsp;...])</td>
<td>Find peaks along a 1D line (peaks in spectrum/spectra).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">fold</span></tt>(*args,&nbsp;**kwargs)</td>
<td>If the signal was previously unfolded, folds it back</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">gaussian_filter</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Applies a Gaussian filter in the spectral dimension in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_factors</span></tt>()</td>
<td>Return the blind source separtion factors as a Signal.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_loadings</span></tt>()</td>
<td>Return the blind source separtion loadings as a Signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_model</span></tt>([components])</td>
<td>Return the spectrum generated with the selected number of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_current_signal</span></tt>([auto_title,&nbsp;auto_filename])</td>
<td>Returns the data at the current coordinates as a Signal subclass.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_factors</span></tt>()</td>
<td>Return the decomposition factors as a Signal.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_loadings</span></tt>()</td>
<td>Return the decomposition loadings as a Signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_model</span></tt>([components])</td>
<td>Return the spectrum generated with the selected number of principal</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_dimensions_from_data</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Get the dimension parameters from the data_cube.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_explained_variance_ratio</span></tt>()</td>
<td>Return the explained variation ratio of the PCA components as a Spectrum.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_histogram</span></tt>(img[,&nbsp;bins,&nbsp;range_bins])</td>
<td>Return a histogram of the signal data.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">hanning_taper</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Apply a hanning taper to the data in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">indexmax</span></tt>(axis)</td>
<td>Returns a signal with the index of the maximum along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate1D</span></tt>(axis)</td>
<td>Integrate the signal over the given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate_in_range</span></tt>([signal_range])</td>
<td>Sums the spectrum over an energy range, giving the integrated area.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate_simpson</span></tt>(axis)</td>
<td>Returns a signal with the result of calculating the integral of the signal along an axis using Simpson&#8217;s rule.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">interpolate_in_between</span></tt>(start,&nbsp;end[,&nbsp;delta,&nbsp;...])</td>
<td>Replace the data in a given range by interpolation.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">map</span></tt>(function[,&nbsp;show_progressbar])</td>
<td>Apply a function to the signal data at all the coordinates.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">max</span></tt>(axis[,&nbsp;return_signal])</td>
<td>Returns a signal with the maximum of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">mean</span></tt>(axis)</td>
<td>Returns a signal with the average of the signal along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">min</span></tt>(axis)</td>
<td>Returns a signal with the minimum of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">next</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">normalize_factors</span></tt>([which,&nbsp;by,&nbsp;sort])</td>
<td>Normalises the factors and modifies the loadings</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">normalize_poissonian_noise</span></tt>([...])</td>
<td>Scales the SI following Surf.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot</span></tt>([navigator,&nbsp;axes_manager])</td>
<td>Plot the signal at the current coordinates.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_factors</span></tt>([comp_ids,&nbsp;calibrate,&nbsp;...])</td>
<td>Plot factors from blind source separation results.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_loadings</span></tt>([comp_ids,&nbsp;calibrate,&nbsp;...])</td>
<td>Plot loadings from ICA</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_results</span></tt>([factors_navigator,&nbsp;...])</td>
<td>Plot the blind source separation factors and loadings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_cumulative_explained_variance_ratio</span></tt>([n])</td>
<td>Plot the principal components explained variance up to the</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_factors</span></tt>([comp_ids,&nbsp;...])</td>
<td>Plot factors from a decomposition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_loadings</span></tt>([comp_ids,&nbsp;...])</td>
<td>Plot loadings from PCA.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_results</span></tt>([...])</td>
<td>Plot the decompostion factors and loadings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_explained_variance_ratio</span></tt>([n,&nbsp;log])</td>
<td>Plot the decomposition explained variance ratio vs index number.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">print_summary_statistics</span></tt>([formatter])</td>
<td>Prints the five-number summary statistics of the data, the mean and the standard deviation.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">rebin</span></tt>(new_shape)</td>
<td>Returns the object with the data rebinned.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">remove_background</span></tt>([signal_range,&nbsp;...])</td>
<td>Remove the background, either in place using a gui or returned as a new spectrum using the command line.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse_bss_component</span></tt>(component_number)</td>
<td>Reverse the independent component</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse_decomposition_component</span></tt>(component_number)</td>
<td>Reverse the decomposition component</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">rollaxis</span></tt>(axis,&nbsp;to_axis)</td>
<td>Roll the specified axis backwards, until it lies in a given position.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">save</span></tt>([filename,&nbsp;overwrite,&nbsp;extension])</td>
<td>Saves the signal in the specified format.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_signal_origin</span></tt>(origin)</td>
<td>Set the origin of the signal and change the current class accordingly if pertinent.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_signal_type</span></tt>(signal_type)</td>
<td>Set the signal type and change the current class accordingly if pertinent.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">shift1D</span></tt>(shift_array[,&nbsp;interpolation_method,&nbsp;...])</td>
<td>Shift the data in place over the signal axis by the amount specified by an array.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_lowess</span></tt>([smoothing_parameter,&nbsp;...])</td>
<td>Lowess data smoothing in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_savitzky_golay</span></tt>([polynomial_order,&nbsp;...])</td>
<td>Apply a Savitzky-Golay filter to the data in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_tv</span></tt>([smoothing_parameter,&nbsp;...])</td>
<td>Total variation data smoothing in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">split</span></tt>([axis,&nbsp;number_of_parts,&nbsp;step_sizes])</td>
<td>Splits the data into several signals.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">squeeze</span></tt>()</td>
<td>Remove single-dimensional entries from the shape of an array and the axes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">std</span></tt>(axis)</td>
<td>Returns a signal with the standard deviation of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">sum</span></tt>(axis)</td>
<td>Sum the data over the given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">swap_axes</span></tt>(axis1,&nbsp;axis2)</td>
<td>Swaps the axes.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_spectrum</span></tt>()</td>
<td>Returns the image as a spectrum.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">undo_treatments</span></tt>()</td>
<td>Undo normalize_poissonian_noise</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold</span></tt>()</td>
<td>Modifies the shape of the data by unfolding the signal and</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_if_multidim</span></tt>()</td>
<td>Unfold the datacube if it is &gt;2D</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_navigation_space</span></tt>()</td>
<td>Modify the shape of the data to obtain a navigation space of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_signal_space</span></tt>()</td>
<td>Modify the shape of the data to obtain a signal space of</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">valuemax</span></tt>(axis)</td>
<td>Returns a signal with the value of the maximum along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">var</span></tt>(axis)</td>
<td>Returns a signal with the variances of the signal along an axis.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.pes">
<span id="hyperspy-signals-pes-module"></span><h2>hyperspy._signals.pes module<a class="headerlink" href="#module-hyperspy._signals.pes" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-hyperspy._signals.simulation">
<span id="hyperspy-signals-simulation-module"></span><h2>hyperspy._signals.simulation module<a class="headerlink" href="#module-hyperspy._signals.simulation" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.simulation.Simulation">
<em class="property">class </em><tt class="descclassname">hyperspy._signals.simulation.</tt><tt class="descname">Simulation</tt><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.simulation.Simulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="hyperspy.html#hyperspy.signal.Signal" title="hyperspy.signal.Signal"><tt class="xref py py-class docutils literal"><span class="pre">hyperspy.signal.Signal</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#hyperspy._signals.simulation.Simulation.add_gaussian_noise" title="hyperspy._signals.simulation.Simulation.add_gaussian_noise"><tt class="xref py py-obj docutils literal"><span class="pre">add_gaussian_noise</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>Add Gaussian noise to the data</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hyperspy._signals.simulation.Simulation.add_poissonian_noise" title="hyperspy._signals.simulation.Simulation.add_poissonian_noise"><tt class="xref py py-obj docutils literal"><span class="pre">add_poissonian_noise</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>Add Poissonian noise to the data</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">align1D</span></tt>([start,&nbsp;end,&nbsp;reference_indices,&nbsp;...])</td>
<td>Estimate the shifts in the signal axis using cross-correlation and use the estimation to align the data in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">align2D</span></tt>([crop,&nbsp;fill_value,&nbsp;shifts,&nbsp;roi,&nbsp;...])</td>
<td>Align the images in place using user provided shifts or by estimating the shifts.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">anscombe</span></tt>()</td>
<td>Anscombe transform.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">anscombe_inverse</span></tt>([method])</td>
<td>Inverse anscombe transform.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_image</span></tt>(image_axes)</td>
<td>Convert signal to image.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_spectrum</span></tt>(spectral_axis)</td>
<td>Return the Signal as a spectrum.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">blind_source_separation</span></tt>([...])</td>
<td>Blind source separation (BSS) on the result on the decomposition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">calibrate</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Calibrate the spectral dimension using a gui.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_dtype</span></tt>(dtype)</td>
<td>Change the data type.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop</span></tt>(axis[,&nbsp;start,&nbsp;end])</td>
<td>Crops the data in a given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop_image</span></tt>([top,&nbsp;bottom,&nbsp;left,&nbsp;right])</td>
<td>Crops an image in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop_spectrum</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Crop in place the spectral dimension.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">decomposition</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Decomposition with a choice of algorithms</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">deepcopy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">diff</span></tt>(axis[,&nbsp;order])</td>
<td>Returns a signal with the n-th order discrete difference along given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_peak_width</span></tt>([factor,&nbsp;window,&nbsp;...])</td>
<td>Estimate the width of the highest intensity of peak of the spectra at a given fraction of its maximum.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_poissonian_noise_variance</span></tt>([...])</td>
<td>Estimate the poissonian noise variance of the signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift1D</span></tt>([start,&nbsp;end,&nbsp;...])</td>
<td>Estimate the shifts in the current signal axis using  cross-correlation.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift2D</span></tt>([reference,&nbsp;...])</td>
<td>Estimate the shifts in a image using phase correlation</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">export_bss_results</span></tt>([comp_ids,&nbsp;folder,&nbsp;...])</td>
<td>Export results from ICA to any of the supported formats.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">export_decomposition_results</span></tt>([comp_ids,&nbsp;...])</td>
<td>Export results from a decomposition to any of the supported formats.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">filter_butterworth</span></tt>([cutoff_frequency_ratio,&nbsp;...])</td>
<td>Butterworth filter in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">find_peaks1D_ohaver</span></tt>([xdim,&nbsp;slope_thresh,&nbsp;...])</td>
<td>Find peaks along a 1D line (peaks in spectrum/spectra).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">fold</span></tt>(*args,&nbsp;**kwargs)</td>
<td>If the signal was previously unfolded, folds it back</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">gaussian_filter</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Applies a Gaussian filter in the spectral dimension in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_factors</span></tt>()</td>
<td>Return the blind source separtion factors as a Signal.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_loadings</span></tt>()</td>
<td>Return the blind source separtion loadings as a Signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_model</span></tt>([components])</td>
<td>Return the spectrum generated with the selected number of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_current_signal</span></tt>([auto_title,&nbsp;auto_filename])</td>
<td>Returns the data at the current coordinates as a Signal subclass.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_factors</span></tt>()</td>
<td>Return the decomposition factors as a Signal.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_loadings</span></tt>()</td>
<td>Return the decomposition loadings as a Signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_model</span></tt>([components])</td>
<td>Return the spectrum generated with the selected number of principal</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_dimensions_from_data</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Get the dimension parameters from the data_cube.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_explained_variance_ratio</span></tt>()</td>
<td>Return the explained variation ratio of the PCA components as a Spectrum.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_histogram</span></tt>(img[,&nbsp;bins,&nbsp;range_bins])</td>
<td>Return a histogram of the signal data.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">hanning_taper</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Apply a hanning taper to the data in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">indexmax</span></tt>(axis)</td>
<td>Returns a signal with the index of the maximum along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate1D</span></tt>(axis)</td>
<td>Integrate the signal over the given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate_in_range</span></tt>([signal_range])</td>
<td>Sums the spectrum over an energy range, giving the integrated area.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate_simpson</span></tt>(axis)</td>
<td>Returns a signal with the result of calculating the integral of the signal along an axis using Simpson&#8217;s rule.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">interpolate_in_between</span></tt>(start,&nbsp;end[,&nbsp;delta,&nbsp;...])</td>
<td>Replace the data in a given range by interpolation.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">map</span></tt>(function[,&nbsp;show_progressbar])</td>
<td>Apply a function to the signal data at all the coordinates.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">max</span></tt>(axis[,&nbsp;return_signal])</td>
<td>Returns a signal with the maximum of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">mean</span></tt>(axis)</td>
<td>Returns a signal with the average of the signal along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">min</span></tt>(axis)</td>
<td>Returns a signal with the minimum of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">next</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">normalize_factors</span></tt>([which,&nbsp;by,&nbsp;sort])</td>
<td>Normalises the factors and modifies the loadings</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">normalize_poissonian_noise</span></tt>([...])</td>
<td>Scales the SI following Surf.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot</span></tt>([navigator,&nbsp;axes_manager])</td>
<td>Plot the signal at the current coordinates.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_factors</span></tt>([comp_ids,&nbsp;calibrate,&nbsp;...])</td>
<td>Plot factors from blind source separation results.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_loadings</span></tt>([comp_ids,&nbsp;calibrate,&nbsp;...])</td>
<td>Plot loadings from ICA</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_results</span></tt>([factors_navigator,&nbsp;...])</td>
<td>Plot the blind source separation factors and loadings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_cumulative_explained_variance_ratio</span></tt>([n])</td>
<td>Plot the principal components explained variance up to the</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_factors</span></tt>([comp_ids,&nbsp;...])</td>
<td>Plot factors from a decomposition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_loadings</span></tt>([comp_ids,&nbsp;...])</td>
<td>Plot loadings from PCA.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_results</span></tt>([...])</td>
<td>Plot the decompostion factors and loadings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_explained_variance_ratio</span></tt>([n,&nbsp;log])</td>
<td>Plot the decomposition explained variance ratio vs index number.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">print_summary_statistics</span></tt>([formatter])</td>
<td>Prints the five-number summary statistics of the data, the mean and the standard deviation.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">rebin</span></tt>(new_shape)</td>
<td>Returns the object with the data rebinned.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">remove_background</span></tt>([signal_range,&nbsp;...])</td>
<td>Remove the background, either in place using a gui or returned as a new spectrum using the command line.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse_bss_component</span></tt>(component_number)</td>
<td>Reverse the independent component</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse_decomposition_component</span></tt>(component_number)</td>
<td>Reverse the decomposition component</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">rollaxis</span></tt>(axis,&nbsp;to_axis)</td>
<td>Roll the specified axis backwards, until it lies in a given position.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">save</span></tt>([filename,&nbsp;overwrite,&nbsp;extension])</td>
<td>Saves the signal in the specified format.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_signal_origin</span></tt>(origin)</td>
<td>Set the origin of the signal and change the current class accordingly if pertinent.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_signal_type</span></tt>(signal_type)</td>
<td>Set the signal type and change the current class accordingly if pertinent.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">shift1D</span></tt>(shift_array[,&nbsp;interpolation_method,&nbsp;...])</td>
<td>Shift the data in place over the signal axis by the amount specified by an array.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_lowess</span></tt>([smoothing_parameter,&nbsp;...])</td>
<td>Lowess data smoothing in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_savitzky_golay</span></tt>([polynomial_order,&nbsp;...])</td>
<td>Apply a Savitzky-Golay filter to the data in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_tv</span></tt>([smoothing_parameter,&nbsp;...])</td>
<td>Total variation data smoothing in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">split</span></tt>([axis,&nbsp;number_of_parts,&nbsp;step_sizes])</td>
<td>Splits the data into several signals.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">squeeze</span></tt>()</td>
<td>Remove single-dimensional entries from the shape of an array and the axes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">std</span></tt>(axis)</td>
<td>Returns a signal with the standard deviation of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">sum</span></tt>(axis)</td>
<td>Sum the data over the given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">swap_axes</span></tt>(axis1,&nbsp;axis2)</td>
<td>Swaps the axes.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">undo_treatments</span></tt>()</td>
<td>Undo normalize_poissonian_noise</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold</span></tt>()</td>
<td>Modifies the shape of the data by unfolding the signal and</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_if_multidim</span></tt>()</td>
<td>Unfold the datacube if it is &gt;2D</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_navigation_space</span></tt>()</td>
<td>Modify the shape of the data to obtain a navigation space of</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_signal_space</span></tt>()</td>
<td>Modify the shape of the data to obtain a signal space of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">valuemax</span></tt>(axis)</td>
<td>Returns a signal with the value of the maximum along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">var</span></tt>(axis)</td>
<td>Returns a signal with the variances of the signal along an axis.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="hyperspy._signals.simulation.Simulation.add_gaussian_noise">
<tt class="descname">add_gaussian_noise</tt><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.simulation.Simulation.add_gaussian_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add Gaussian noise to the data
Parameters
&#8212;&#8212;&#8212;-
std : float</p>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.simulation.Simulation.add_poissonian_noise">
<tt class="descname">add_poissonian_noise</tt><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.simulation.Simulation.add_poissonian_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add Poissonian noise to the data</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.spectrum">
<span id="hyperspy-signals-spectrum-module"></span><h2>hyperspy._signals.spectrum module<a class="headerlink" href="#module-hyperspy._signals.spectrum" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.spectrum.Spectrum">
<em class="property">class </em><tt class="descclassname">hyperspy._signals.spectrum.</tt><tt class="descname">Spectrum</tt><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.spectrum.Spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="hyperspy.html#hyperspy.signal.Signal" title="hyperspy.signal.Signal"><tt class="xref py py-class docutils literal"><span class="pre">hyperspy.signal.Signal</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">align1D</span></tt>([start,&nbsp;end,&nbsp;reference_indices,&nbsp;...])</td>
<td>Estimate the shifts in the signal axis using cross-correlation and use the estimation to align the data in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">align2D</span></tt>([crop,&nbsp;fill_value,&nbsp;shifts,&nbsp;roi,&nbsp;...])</td>
<td>Align the images in place using user provided shifts or by estimating the shifts.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">anscombe</span></tt>()</td>
<td>Anscombe transform.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">anscombe_inverse</span></tt>([method])</td>
<td>Inverse anscombe transform.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_image</span></tt>(image_axes)</td>
<td>Convert signal to image.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_spectrum</span></tt>(spectral_axis)</td>
<td>Return the Signal as a spectrum.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">blind_source_separation</span></tt>([...])</td>
<td>Blind source separation (BSS) on the result on the decomposition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">calibrate</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Calibrate the spectral dimension using a gui.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_dtype</span></tt>(dtype)</td>
<td>Change the data type.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop</span></tt>(axis[,&nbsp;start,&nbsp;end])</td>
<td>Crops the data in a given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop_image</span></tt>([top,&nbsp;bottom,&nbsp;left,&nbsp;right])</td>
<td>Crops an image in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop_spectrum</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Crop in place the spectral dimension.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">decomposition</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Decomposition with a choice of algorithms</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">deepcopy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">diff</span></tt>(axis[,&nbsp;order])</td>
<td>Returns a signal with the n-th order discrete difference along given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_peak_width</span></tt>([factor,&nbsp;window,&nbsp;...])</td>
<td>Estimate the width of the highest intensity of peak of the spectra at a given fraction of its maximum.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_poissonian_noise_variance</span></tt>([...])</td>
<td>Estimate the poissonian noise variance of the signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift1D</span></tt>([start,&nbsp;end,&nbsp;...])</td>
<td>Estimate the shifts in the current signal axis using  cross-correlation.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift2D</span></tt>([reference,&nbsp;...])</td>
<td>Estimate the shifts in a image using phase correlation</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">export_bss_results</span></tt>([comp_ids,&nbsp;folder,&nbsp;...])</td>
<td>Export results from ICA to any of the supported formats.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">export_decomposition_results</span></tt>([comp_ids,&nbsp;...])</td>
<td>Export results from a decomposition to any of the supported formats.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">filter_butterworth</span></tt>([cutoff_frequency_ratio,&nbsp;...])</td>
<td>Butterworth filter in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">find_peaks1D_ohaver</span></tt>([xdim,&nbsp;slope_thresh,&nbsp;...])</td>
<td>Find peaks along a 1D line (peaks in spectrum/spectra).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">fold</span></tt>(*args,&nbsp;**kwargs)</td>
<td>If the signal was previously unfolded, folds it back</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">gaussian_filter</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Applies a Gaussian filter in the spectral dimension in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_factors</span></tt>()</td>
<td>Return the blind source separtion factors as a Signal.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_loadings</span></tt>()</td>
<td>Return the blind source separtion loadings as a Signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_model</span></tt>([components])</td>
<td>Return the spectrum generated with the selected number of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_current_signal</span></tt>([auto_title,&nbsp;auto_filename])</td>
<td>Returns the data at the current coordinates as a Signal subclass.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_factors</span></tt>()</td>
<td>Return the decomposition factors as a Signal.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_loadings</span></tt>()</td>
<td>Return the decomposition loadings as a Signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_model</span></tt>([components])</td>
<td>Return the spectrum generated with the selected number of principal</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_dimensions_from_data</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Get the dimension parameters from the data_cube.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_explained_variance_ratio</span></tt>()</td>
<td>Return the explained variation ratio of the PCA components as a Spectrum.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_histogram</span></tt>(img[,&nbsp;bins,&nbsp;range_bins])</td>
<td>Return a histogram of the signal data.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">hanning_taper</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Apply a hanning taper to the data in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">indexmax</span></tt>(axis)</td>
<td>Returns a signal with the index of the maximum along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate1D</span></tt>(axis)</td>
<td>Integrate the signal over the given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate_in_range</span></tt>([signal_range])</td>
<td>Sums the spectrum over an energy range, giving the integrated area.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate_simpson</span></tt>(axis)</td>
<td>Returns a signal with the result of calculating the integral of the signal along an axis using Simpson&#8217;s rule.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">interpolate_in_between</span></tt>(start,&nbsp;end[,&nbsp;delta,&nbsp;...])</td>
<td>Replace the data in a given range by interpolation.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">map</span></tt>(function[,&nbsp;show_progressbar])</td>
<td>Apply a function to the signal data at all the coordinates.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">max</span></tt>(axis[,&nbsp;return_signal])</td>
<td>Returns a signal with the maximum of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">mean</span></tt>(axis)</td>
<td>Returns a signal with the average of the signal along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">min</span></tt>(axis)</td>
<td>Returns a signal with the minimum of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">next</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">normalize_factors</span></tt>([which,&nbsp;by,&nbsp;sort])</td>
<td>Normalises the factors and modifies the loadings</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">normalize_poissonian_noise</span></tt>([...])</td>
<td>Scales the SI following Surf.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot</span></tt>([navigator,&nbsp;axes_manager])</td>
<td>Plot the signal at the current coordinates.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_factors</span></tt>([comp_ids,&nbsp;calibrate,&nbsp;...])</td>
<td>Plot factors from blind source separation results.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_loadings</span></tt>([comp_ids,&nbsp;calibrate,&nbsp;...])</td>
<td>Plot loadings from ICA</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_results</span></tt>([factors_navigator,&nbsp;...])</td>
<td>Plot the blind source separation factors and loadings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_cumulative_explained_variance_ratio</span></tt>([n])</td>
<td>Plot the principal components explained variance up to the</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_factors</span></tt>([comp_ids,&nbsp;...])</td>
<td>Plot factors from a decomposition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_loadings</span></tt>([comp_ids,&nbsp;...])</td>
<td>Plot loadings from PCA.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_results</span></tt>([...])</td>
<td>Plot the decompostion factors and loadings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_explained_variance_ratio</span></tt>([n,&nbsp;log])</td>
<td>Plot the decomposition explained variance ratio vs index number.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">print_summary_statistics</span></tt>([formatter])</td>
<td>Prints the five-number summary statistics of the data, the mean and the standard deviation.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">rebin</span></tt>(new_shape)</td>
<td>Returns the object with the data rebinned.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">remove_background</span></tt>([signal_range,&nbsp;...])</td>
<td>Remove the background, either in place using a gui or returned as a new spectrum using the command line.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse_bss_component</span></tt>(component_number)</td>
<td>Reverse the independent component</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse_decomposition_component</span></tt>(component_number)</td>
<td>Reverse the decomposition component</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">rollaxis</span></tt>(axis,&nbsp;to_axis)</td>
<td>Roll the specified axis backwards, until it lies in a given position.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">save</span></tt>([filename,&nbsp;overwrite,&nbsp;extension])</td>
<td>Saves the signal in the specified format.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_signal_origin</span></tt>(origin)</td>
<td>Set the origin of the signal and change the current class accordingly if pertinent.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_signal_type</span></tt>(signal_type)</td>
<td>Set the signal type and change the current class accordingly if pertinent.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">shift1D</span></tt>(shift_array[,&nbsp;interpolation_method,&nbsp;...])</td>
<td>Shift the data in place over the signal axis by the amount specified by an array.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_lowess</span></tt>([smoothing_parameter,&nbsp;...])</td>
<td>Lowess data smoothing in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_savitzky_golay</span></tt>([polynomial_order,&nbsp;...])</td>
<td>Apply a Savitzky-Golay filter to the data in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_tv</span></tt>([smoothing_parameter,&nbsp;...])</td>
<td>Total variation data smoothing in place.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hyperspy._signals.spectrum.Spectrum.spikes_removal_tool" title="hyperspy._signals.spectrum.Spectrum.spikes_removal_tool"><tt class="xref py py-obj docutils literal"><span class="pre">spikes_removal_tool</span></tt></a>([signal_mask,&nbsp;...])</td>
<td>Graphical interface to remove spikes from EELS spectra.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">split</span></tt>([axis,&nbsp;number_of_parts,&nbsp;step_sizes])</td>
<td>Splits the data into several signals.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">squeeze</span></tt>()</td>
<td>Remove single-dimensional entries from the shape of an array and the axes.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">std</span></tt>(axis)</td>
<td>Returns a signal with the standard deviation of the signal along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">sum</span></tt>(axis)</td>
<td>Sum the data over the given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">swap_axes</span></tt>(axis1,&nbsp;axis2)</td>
<td>Swaps the axes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hyperspy._signals.spectrum.Spectrum.to_EDS" title="hyperspy._signals.spectrum.Spectrum.to_EDS"><tt class="xref py py-obj docutils literal"><span class="pre">to_EDS</span></tt></a>([microscope])</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#hyperspy._signals.spectrum.Spectrum.to_EELS" title="hyperspy._signals.spectrum.Spectrum.to_EELS"><tt class="xref py py-obj docutils literal"><span class="pre">to_EELS</span></tt></a>()</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#hyperspy._signals.spectrum.Spectrum.to_image" title="hyperspy._signals.spectrum.Spectrum.to_image"><tt class="xref py py-obj docutils literal"><span class="pre">to_image</span></tt></a>()</td>
<td>Returns the spectrum as an image.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">undo_treatments</span></tt>()</td>
<td>Undo normalize_poissonian_noise</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold</span></tt>()</td>
<td>Modifies the shape of the data by unfolding the signal and</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_if_multidim</span></tt>()</td>
<td>Unfold the datacube if it is &gt;2D</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_navigation_space</span></tt>()</td>
<td>Modify the shape of the data to obtain a navigation space of</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_signal_space</span></tt>()</td>
<td>Modify the shape of the data to obtain a signal space of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">valuemax</span></tt>(axis)</td>
<td>Returns a signal with the value of the maximum along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">var</span></tt>(axis)</td>
<td>Returns a signal with the variances of the signal along an axis.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="hyperspy._signals.spectrum.Spectrum.spikes_removal_tool">
<tt class="descname">spikes_removal_tool</tt><span class="sig-paren">(</span><em>signal_mask=None</em>, <em>navigation_mask=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.spectrum.Spectrum.spikes_removal_tool" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphical interface to remove spikes from EELS spectra.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>signal_mask: boolean array</strong> :</p>
<blockquote>
<div><p>Restricts the operation to the signal locations not marked
as True (masked)</p>
</div></blockquote>
<p><strong>navigation_mask: boolean array</strong> :</p>
<blockquote class="last">
<div><p>Restricts the operation to the navigation locations not
marked as True (masked)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">_spikes_diagnosis</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="hyperspy._signals.spectrum.Spectrum.to_EDS">
<tt class="descname">to_EDS</tt><span class="sig-paren">(</span><em>microscope=None</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.spectrum.Spectrum.to_EDS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hyperspy._signals.spectrum.Spectrum.to_EELS">
<tt class="descname">to_EELS</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.spectrum.Spectrum.to_EELS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="hyperspy._signals.spectrum.Spectrum.to_image">
<tt class="descname">to_image</tt><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.spectrum.Spectrum.to_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the spectrum as an image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><strong>DataDimensionError: when data.ndim &lt; 2</strong> :</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><tt class="xref py py-obj docutils literal"><span class="pre">as_image</span></tt></dt>
<dd>a method for the same purpose with more options.</dd>
<dt><tt class="xref py py-obj docutils literal"><span class="pre">signals.Spectrum.to_image</span></tt></dt>
<dd>performs the inverse operation on images.</dd>
</dl>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals.spectrum_simulation">
<span id="hyperspy-signals-spectrum-simulation-module"></span><h2>hyperspy._signals.spectrum_simulation module<a class="headerlink" href="#module-hyperspy._signals.spectrum_simulation" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="hyperspy._signals.spectrum_simulation.SpectrumSimulation">
<em class="property">class </em><tt class="descclassname">hyperspy._signals.spectrum_simulation.</tt><tt class="descname">SpectrumSimulation</tt><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#hyperspy._signals.spectrum_simulation.SpectrumSimulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#hyperspy._signals.simulation.Simulation" title="hyperspy._signals.simulation.Simulation"><tt class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.simulation.Simulation</span></tt></a>, <a class="reference internal" href="#hyperspy._signals.spectrum.Spectrum" title="hyperspy._signals.spectrum.Spectrum"><tt class="xref py py-class docutils literal"><span class="pre">hyperspy._signals.spectrum.Spectrum</span></tt></a></p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">add_gaussian_noise</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Add Gaussian noise to the data</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">add_poissonian_noise</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Add Poissonian noise to the data</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">align1D</span></tt>([start,&nbsp;end,&nbsp;reference_indices,&nbsp;...])</td>
<td>Estimate the shifts in the signal axis using cross-correlation and use the estimation to align the data in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">align2D</span></tt>([crop,&nbsp;fill_value,&nbsp;shifts,&nbsp;roi,&nbsp;...])</td>
<td>Align the images in place using user provided shifts or by estimating the shifts.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">anscombe</span></tt>()</td>
<td>Anscombe transform.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">anscombe_inverse</span></tt>([method])</td>
<td>Inverse anscombe transform.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_image</span></tt>(image_axes)</td>
<td>Convert signal to image.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">as_spectrum</span></tt>(spectral_axis)</td>
<td>Return the Signal as a spectrum.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">blind_source_separation</span></tt>([...])</td>
<td>Blind source separation (BSS) on the result on the decomposition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">calibrate</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Calibrate the spectral dimension using a gui.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">change_dtype</span></tt>(dtype)</td>
<td>Change the data type.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop</span></tt>(axis[,&nbsp;start,&nbsp;end])</td>
<td>Crops the data in a given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop_image</span></tt>([top,&nbsp;bottom,&nbsp;left,&nbsp;right])</td>
<td>Crops an image in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">crop_spectrum</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Crop in place the spectral dimension.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">decomposition</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Decomposition with a choice of algorithms</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">deepcopy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">diff</span></tt>(axis[,&nbsp;order])</td>
<td>Returns a signal with the n-th order discrete difference along given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_peak_width</span></tt>([factor,&nbsp;window,&nbsp;...])</td>
<td>Estimate the width of the highest intensity of peak of the spectra at a given fraction of its maximum.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_poissonian_noise_variance</span></tt>([...])</td>
<td>Estimate the poissonian noise variance of the signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift1D</span></tt>([start,&nbsp;end,&nbsp;...])</td>
<td>Estimate the shifts in the current signal axis using  cross-correlation.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">estimate_shift2D</span></tt>([reference,&nbsp;...])</td>
<td>Estimate the shifts in a image using phase correlation</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">export_bss_results</span></tt>([comp_ids,&nbsp;folder,&nbsp;...])</td>
<td>Export results from ICA to any of the supported formats.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">export_decomposition_results</span></tt>([comp_ids,&nbsp;...])</td>
<td>Export results from a decomposition to any of the supported formats.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">filter_butterworth</span></tt>([cutoff_frequency_ratio,&nbsp;...])</td>
<td>Butterworth filter in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">find_peaks1D_ohaver</span></tt>([xdim,&nbsp;slope_thresh,&nbsp;...])</td>
<td>Find peaks along a 1D line (peaks in spectrum/spectra).</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">fold</span></tt>(*args,&nbsp;**kwargs)</td>
<td>If the signal was previously unfolded, folds it back</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">gaussian_filter</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Applies a Gaussian filter in the spectral dimension in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_factors</span></tt>()</td>
<td>Return the blind source separtion factors as a Signal.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_loadings</span></tt>()</td>
<td>Return the blind source separtion loadings as a Signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_bss_model</span></tt>([components])</td>
<td>Return the spectrum generated with the selected number of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_current_signal</span></tt>([auto_title,&nbsp;auto_filename])</td>
<td>Returns the data at the current coordinates as a Signal subclass.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_factors</span></tt>()</td>
<td>Return the decomposition factors as a Signal.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_loadings</span></tt>()</td>
<td>Return the decomposition loadings as a Signal.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_decomposition_model</span></tt>([components])</td>
<td>Return the spectrum generated with the selected number of principal</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_dimensions_from_data</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Get the dimension parameters from the data_cube.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_explained_variance_ratio</span></tt>()</td>
<td>Return the explained variation ratio of the PCA components as a Spectrum.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_histogram</span></tt>(img[,&nbsp;bins,&nbsp;range_bins])</td>
<td>Return a histogram of the signal data.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">hanning_taper</span></tt>(*args,&nbsp;**kwargs)</td>
<td>Apply a hanning taper to the data in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">indexmax</span></tt>(axis)</td>
<td>Returns a signal with the index of the maximum along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate1D</span></tt>(axis)</td>
<td>Integrate the signal over the given axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate_in_range</span></tt>([signal_range])</td>
<td>Sums the spectrum over an energy range, giving the integrated area.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">integrate_simpson</span></tt>(axis)</td>
<td>Returns a signal with the result of calculating the integral of the signal along an axis using Simpson&#8217;s rule.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">interpolate_in_between</span></tt>(start,&nbsp;end[,&nbsp;delta,&nbsp;...])</td>
<td>Replace the data in a given range by interpolation.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">map</span></tt>(function[,&nbsp;show_progressbar])</td>
<td>Apply a function to the signal data at all the coordinates.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">max</span></tt>(axis[,&nbsp;return_signal])</td>
<td>Returns a signal with the maximum of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">mean</span></tt>(axis)</td>
<td>Returns a signal with the average of the signal along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">min</span></tt>(axis)</td>
<td>Returns a signal with the minimum of the signal along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">next</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">normalize_factors</span></tt>([which,&nbsp;by,&nbsp;sort])</td>
<td>Normalises the factors and modifies the loadings</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">normalize_poissonian_noise</span></tt>([...])</td>
<td>Scales the SI following Surf.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot</span></tt>([navigator,&nbsp;axes_manager])</td>
<td>Plot the signal at the current coordinates.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_factors</span></tt>([comp_ids,&nbsp;calibrate,&nbsp;...])</td>
<td>Plot factors from blind source separation results.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_loadings</span></tt>([comp_ids,&nbsp;calibrate,&nbsp;...])</td>
<td>Plot loadings from ICA</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_bss_results</span></tt>([factors_navigator,&nbsp;...])</td>
<td>Plot the blind source separation factors and loadings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_cumulative_explained_variance_ratio</span></tt>([n])</td>
<td>Plot the principal components explained variance up to the</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_factors</span></tt>([comp_ids,&nbsp;...])</td>
<td>Plot factors from a decomposition.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_loadings</span></tt>([comp_ids,&nbsp;...])</td>
<td>Plot loadings from PCA.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_decomposition_results</span></tt>([...])</td>
<td>Plot the decompostion factors and loadings.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">plot_explained_variance_ratio</span></tt>([n,&nbsp;log])</td>
<td>Plot the decomposition explained variance ratio vs index number.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">print_summary_statistics</span></tt>([formatter])</td>
<td>Prints the five-number summary statistics of the data, the mean and the standard deviation.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">rebin</span></tt>(new_shape)</td>
<td>Returns the object with the data rebinned.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">remove_background</span></tt>([signal_range,&nbsp;...])</td>
<td>Remove the background, either in place using a gui or returned as a new spectrum using the command line.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse_bss_component</span></tt>(component_number)</td>
<td>Reverse the independent component</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse_decomposition_component</span></tt>(component_number)</td>
<td>Reverse the decomposition component</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">rollaxis</span></tt>(axis,&nbsp;to_axis)</td>
<td>Roll the specified axis backwards, until it lies in a given position.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">save</span></tt>([filename,&nbsp;overwrite,&nbsp;extension])</td>
<td>Saves the signal in the specified format.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_signal_origin</span></tt>(origin)</td>
<td>Set the origin of the signal and change the current class accordingly if pertinent.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">set_signal_type</span></tt>(signal_type)</td>
<td>Set the signal type and change the current class accordingly if pertinent.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">shift1D</span></tt>(shift_array[,&nbsp;interpolation_method,&nbsp;...])</td>
<td>Shift the data in place over the signal axis by the amount specified by an array.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_lowess</span></tt>([smoothing_parameter,&nbsp;...])</td>
<td>Lowess data smoothing in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_savitzky_golay</span></tt>([polynomial_order,&nbsp;...])</td>
<td>Apply a Savitzky-Golay filter to the data in place.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">smooth_tv</span></tt>([smoothing_parameter,&nbsp;...])</td>
<td>Total variation data smoothing in place.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">spikes_removal_tool</span></tt>([signal_mask,&nbsp;...])</td>
<td>Graphical interface to remove spikes from EELS spectra.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">split</span></tt>([axis,&nbsp;number_of_parts,&nbsp;step_sizes])</td>
<td>Splits the data into several signals.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">squeeze</span></tt>()</td>
<td>Remove single-dimensional entries from the shape of an array and the axes.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">std</span></tt>(axis)</td>
<td>Returns a signal with the standard deviation of the signal along an axis.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">sum</span></tt>(axis)</td>
<td>Sum the data over the given axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">swap_axes</span></tt>(axis1,&nbsp;axis2)</td>
<td>Swaps the axes.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_EDS</span></tt>([microscope])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_EELS</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_image</span></tt>()</td>
<td>Returns the spectrum as an image.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">undo_treatments</span></tt>()</td>
<td>Undo normalize_poissonian_noise</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold</span></tt>()</td>
<td>Modifies the shape of the data by unfolding the signal and</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_if_multidim</span></tt>()</td>
<td>Unfold the datacube if it is &gt;2D</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_navigation_space</span></tt>()</td>
<td>Modify the shape of the data to obtain a navigation space of</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">unfold_signal_space</span></tt>()</td>
<td>Modify the shape of the data to obtain a signal space of</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">valuemax</span></tt>(axis)</td>
<td>Returns a signal with the value of the maximum along an axis.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">var</span></tt>(axis)</td>
<td>Returns a signal with the variances of the signal along an axis.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-hyperspy._signals">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-hyperspy._signals" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/hyperspy_logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">hyperspy._signals package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-hyperspy._signals.dielectric_function">hyperspy._signals.dielectric_function module</a></li>
<li><a class="reference internal" href="#module-hyperspy._signals.eds">hyperspy._signals.eds module</a></li>
<li><a class="reference internal" href="#module-hyperspy._signals.eds_sem">hyperspy._signals.eds_sem module</a></li>
<li><a class="reference internal" href="#module-hyperspy._signals.eds_tem">hyperspy._signals.eds_tem module</a></li>
<li><a class="reference internal" href="#module-hyperspy._signals.eels">hyperspy._signals.eels module</a></li>
<li><a class="reference internal" href="#module-hyperspy._signals.eels_spectrum_simulation">hyperspy._signals.eels_spectrum_simulation module</a></li>
<li><a class="reference internal" href="#module-hyperspy._signals.image">hyperspy._signals.image module</a></li>
<li><a class="reference internal" href="#module-hyperspy._signals.image_simulation">hyperspy._signals.image_simulation module</a></li>
<li><a class="reference internal" href="#module-hyperspy._signals.pes">hyperspy._signals.pes module</a></li>
<li><a class="reference internal" href="#module-hyperspy._signals.simulation">hyperspy._signals.simulation module</a></li>
<li><a class="reference internal" href="#module-hyperspy._signals.spectrum">hyperspy._signals.spectrum module</a></li>
<li><a class="reference internal" href="#module-hyperspy._signals.spectrum_simulation">hyperspy._signals.spectrum_simulation module</a></li>
<li><a class="reference internal" href="#module-hyperspy._signals">Module contents</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/api/hyperspy._signals.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">HyperSpy 0.8+dev documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2012, The HyperSpy development team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3a0.
    </div>
  </body>
</html>